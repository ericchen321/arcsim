!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AccelStruct	collisionutil.cpp	/^AccelStruct::AccelStruct (const Mesh &mesh, bool ccd):$/;"	f	class:AccelStruct
AccelStruct	collisionutil.hpp	/^struct AccelStruct {$/;"	s
Annotation	display.hpp	/^	Annotation(Face* f, Edge* e, Node* n, Vec3 c, Vec3 p, Vec3 d=Vec3(0)) : $/;"	f	struct:Annotation
Annotation	display.hpp	/^struct Annotation {$/;"	s
BLOCKVECTORS_HPP	blockvectors.hpp	28;"	d
BOX	bvh.hpp	260;"	d
BREAKING_HPP	breaking.hpp	28;"	d
BVHCallback	collisionutil.hpp	/^typedef void (*BVHCallback) (const Face *face0, const Face *face1);$/;"	t
BVHNode	collisionutil.hpp	/^typedef DeformBVHNode BVHNode;$/;"	t
BVHTree	collisionutil.hpp	/^typedef DeformBVHTree BVHTree;$/;"	t
Bary	separate.cpp	/^typedef Vec3 Bary; \/\/ barycentric coordinates$/;"	t	file:
Bary	separateobs.cpp	/^typedef Vec3 Bary; \/\/ barycentric coordinates$/;"	t	namespace:SO	file:
BendingData	dde.hpp	/^struct BendingData {double d[3][5];};$/;"	s
BodyFrame	mot_parser.hpp	/^struct BodyFrame$/;"	s
BodyFrameVector	mot_parser.hpp	/^typedef std::vector<BodyFrame> BodyFrameVector;$/;"	t
BodyVector	mot_parser.hpp	/^typedef std::vector<BodyFrameVector> BodyVector; $/;"	t
Box	conf.cpp	/^    Box () {}$/;"	f	struct:Box
Box	conf.cpp	/^    Box (const Vec2 &umin, const Vec2 &umax): umin(umin), umax(umax) {}$/;"	f	struct:Box
Box	conf.cpp	/^struct Box {$/;"	s	file:
CLOTH_HPP	cloth.hpp	28;"	d
COLLISIONUTIL_HPP	collisionutil.hpp	28;"	d
COLLISION_HPP	collision.hpp	28;"	d
CONF_HPP	conf.hpp	28;"	d
CONSTRAINT_HPP	constraint.hpp	28;"	d
Check	util.hpp	/^	enum Mode { Load = 0, Save, Check };$/;"	e	enum:Serialize::Mode
CircleHandle	handle.hpp	/^struct CircleHandle: public Handle {$/;"	s
Cloth	cloth.hpp	/^struct Cloth {$/;"	s
Collision	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon2
CollisionProxy	proxy.hpp	/^class CollisionProxy {$/;"	c
Constraint	constraint.hpp	/^struct Constraint {$/;"	s
Construct	bvh.cpp	/^DeformBVHTree::Construct()$/;"	f	class:DeformBVHTree
DDE_HPP	dde.hpp	28;"	d
DEFXYR	tensormax.cpp	113;"	d	file:
DEFXYR	tensormax.cpp	117;"	d	file:
DISPLAYPHYSICS_HPP	displayphysics.hpp	28;"	d
DISPLAYREPLAY_HPP	displayreplay.hpp	28;"	d
DISPLAYTESTING_HPP	displaytesting.hpp	28;"	d
DISPLAY_HPP	display.hpp	28;"	d
DTransformation	transformation.hpp	/^typedef std::pair<Transformation,Transformation> DTransformation;$/;"	t
DYNAMICREMESH_HPP	dynamicremesh.hpp	28;"	d
DeformBVHNode	bvh.cpp	/^DeformBVHNode::DeformBVHNode()$/;"	f	class:DeformBVHNode
DeformBVHNode	bvh.cpp	/^DeformBVHNode::DeformBVHNode(DeformBVHNode *parent, Face **lst, unsigned int lst_num, std::map<Face*,BOX>& tri_boxes, std::map<Face*,vec3f>& tri_centers)$/;"	f	class:DeformBVHNode
DeformBVHNode	bvh.cpp	/^DeformBVHNode::DeformBVHNode(DeformBVHNode *parent, Face *face, std::map<Face*,BOX>& tri_boxes)$/;"	f	class:DeformBVHNode
DeformBVHNode	bvh.hpp	/^class DeformBVHNode {$/;"	c
DeformBVHTree	bvh.cpp	/^DeformBVHTree::DeformBVHTree(DeformModel &mdl, bool ccd)$/;"	f	class:DeformBVHTree
DeformBVHTree	bvh.hpp	/^class DeformBVHTree {$/;"	c
DeformModel	bvh.hpp	/^typedef Mesh DeformModel;$/;"	t
Deterministic_sort	dynamicremesh.cpp	/^struct Deterministic_sort {$/;"	s	file:
Disk	tensormax.cpp	/^    Disk (): c(Vec2(0)), r(0) {}$/;"	f	struct:Disk
Disk	tensormax.cpp	/^    Disk (const Vec2 &c, double r): c(c), r(r) {}$/;"	f	struct:Disk
Disk	tensormax.cpp	/^struct Disk {$/;"	s	file:
DisplayMode	display.cpp	/^struct DisplayMode { string name; double scale; bool active; };$/;"	s	file:
Dm	mesh.hpp	/^    Mat3x3 Dm, invDm; \/\/ finite element matrix$/;"	m	struct:Face
ECHO	util.hpp	198;"	d
EE	collision.cpp	/^    enum Type {VF, EE} type;$/;"	e	enum:Impact::Type	file:
EPSILON	util.hpp	40;"	d
Edge	mesh.hpp	/^    Edge () : index(-1), theta_ideal(0), damage(0) { n[0]=n[1]=0; adjf[0]=adjf[1]=0; }$/;"	f	struct:Edge
Edge	mesh.hpp	/^    explicit Edge (Node *node0, Node *node1, double theta_ideal, int preserve):$/;"	f	struct:Edge
Edge	mesh.hpp	/^struct Edge {$/;"	s
EdgeClipping	separate.cpp	/^    EdgeClipping () {t[0] = 0; t[1] = 1; edge[0] = edge[1] = NULL;}$/;"	f	struct:EdgeClipping
EdgeClipping	separate.cpp	/^struct EdgeClipping {$/;"	s	file:
Eig	vectors.hpp	/^template <int n> struct Eig {$/;"	s
EmbedOpt	plasticity.cpp	/^    EmbedOpt (Cloth &cloth): cloth(cloth), mesh(cloth.mesh) {$/;"	f	struct:EmbedOpt
EmbedOpt	plasticity.cpp	/^struct EmbedOpt: public NLOpt {$/;"	s	file:
EqCon	constraint.hpp	/^struct EqCon: public Constraint {$/;"	s
F	localopt.cpp	/^    mutable vector<Vec3> F;$/;"	m	struct:LocalOpt	file:
FILE_VERSION	io.cpp	/^const int FILE_VERSION = 1;$/;"	v
FORCEINLINE	bvh.hpp	57;"	d
Face	mesh.hpp	/^    Face () : material(0), flag(0), index(-1), a(0), m(0), damage(0) { $/;"	f	struct:Face
Face	mesh.hpp	/^    explicit Face (Vert *vert0, Vert *vert1, Vert *vert2, const Mat3x3& ps, $/;"	f	struct:Face
Face	mesh.hpp	/^struct Face {$/;"	s
FanPrecomp	sepstrength.cpp	/^struct FanPrecomp {$/;"	s	file:
FlagActive	mesh.hpp	/^	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, $/;"	e	enum:Node::NodeFlags
FlagMayBreak	mesh.hpp	/^	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, $/;"	e	enum:Node::NodeFlags
FlagNone	mesh.hpp	/^	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, $/;"	e	enum:Node::NodeFlags
FlagResolveMax	mesh.hpp	/^                     FlagResolveUni = 4, FlagResolveMax = 8 };$/;"	e	enum:Node::NodeFlags
FlagResolveUni	mesh.hpp	/^                     FlagResolveUni = 4, FlagResolveMax = 8 };$/;"	e	enum:Node::NodeFlags
FloorProxy	proxy.cpp	/^FloorProxy::FloorProxy(Mesh& mesh){$/;"	f	class:FloorProxy
FloorProxy	proxy.hpp	/^class FloorProxy : public CollisionProxy {$/;"	c
Fracture	simulation.hpp	/^          PopFilter, Plasticity, Fracture, nModules};$/;"	e	enum:Simulation::__anon2
GEOMETRY_HPP	geometry.hpp	28;"	d
GL_GLEXT_PROTOTYPES	opengl.hpp	32;"	d
GlueCon	constraint.hpp	/^struct GlueCon: public Constraint {$/;"	s
GlueHandle	handle.hpp	/^struct GlueHandle: public Handle {$/;"	s
GlutCallbacks	display.hpp	/^    GlutCallbacks (): idle(NULL), keyboard(NULL), special(NULL) {}$/;"	f	struct:GlutCallbacks
GlutCallbacks	display.hpp	/^struct GlutCallbacks {$/;"	s
HANDLE_HPP	handle.hpp	28;"	d
Handle	handle.hpp	/^struct Handle {$/;"	s
IO_HPP	io.hpp	28;"	d
Impact	collision.cpp	/^    Impact () {}$/;"	f	struct:Impact
Impact	collision.cpp	/^    Impact (Type type, const Node *n0, const Node *n1, const Node *n2,$/;"	f	struct:Impact
Impact	collision.cpp	/^struct Impact {$/;"	s	file:
ImpactZone	collision.cpp	/^struct ImpactZone {$/;"	s	file:
IneqCon	constraint.hpp	/^struct IneqCon: public Constraint {$/;"	s
Ixn	separate.cpp	/^    Ixn () {}$/;"	f	struct:Ixn
Ixn	separate.cpp	/^    Ixn (const Face *f0, const Face *f1)$/;"	f	struct:Ixn
Ixn	separate.cpp	/^struct Ixn {  \/\/ intersection$/;"	s	file:
Ixn	separateobs.cpp	/^    Ixn () {}$/;"	f	struct:SO::Ixn
Ixn	separateobs.cpp	/^    Ixn (const Face *f0, const Bary &b0, const Face *f1, const Bary &b1,$/;"	f	struct:SO::Ixn
Ixn	separateobs.cpp	/^struct Ixn {\/\/ intersection$/;"	s	namespace:SO	file:
J	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};$/;"	m	struct:MeshHessV
J	localopt.cpp	/^    mutable SpMat<Mat3x3> J;$/;"	m	struct:LocalOpt	file:
J	plasticity.cpp	/^    mutable SpMat<Mat3x3> J;$/;"	m	struct:EmbedOpt	file:
J	popfilter.cpp	/^    mutable SpMat<Mat3x3> J;$/;"	m	struct:PopOpt	file:
LAPACKE_dgesvd	vectors.cpp	38;"	d	file:
LAPACKE_dsyev	vectors.cpp	39;"	d	file:
LAPACK_COL_MAJOR	vectors.cpp	44;"	d	file:
LAPACK_ROW_MAJOR	vectors.cpp	43;"	d	file:
LOCALOPT_HPP	localopt.hpp	2;"	d
Line3	separate.cpp	/^typedef std::pair<Vec3, Vec3> Line3;$/;"	t	file:
Load	util.hpp	/^	enum Mode { Load = 0, Save, Check };$/;"	e	enum:Serialize::Mode
LocalOpt	localopt.cpp	/^LocalOpt<s>::LocalOpt(vector<Node*>& nodes, const vector<Face*>& faces, const vector<Edge*>& edges, $/;"	f	class:LocalOpt
LocalOpt	localopt.cpp	/^struct LocalOpt: public NLOpt {$/;"	s	file:
MAGIC_HPP	magic.hpp	28;"	d
MAX	bvh.hpp	53;"	d
MESH_HPP	mesh.hpp	28;"	d
MIN	bvh.hpp	54;"	d
MISC_HPP	misc.hpp	28;"	d
MORPH_HPP	morph.hpp	2;"	d
MOT_PARSER_HPP	mot_parser.hpp	28;"	d
MS	geometry.hpp	/^enum Space {MS, PS, WS}; \/\/ material space, plastic space, world space$/;"	e	enum:Space
Magic	magic.hpp	/^    Magic ():$/;"	f	struct:Magic
Magic	magic.hpp	/^struct Magic {$/;"	s
Mat	vectors.hpp	/^    Mat () {for (int j = 0; j < n; j++) c[j] = VecmT(0);}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (T x) {for (int j = 0; j < n; j++) {c[j] = VecmT(0); if (j < m) c[j][j] = x;}}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (VecmT x, VecmT y) {static_assert(n==2); c[0] = x; c[1] = y;}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (VecmT x, VecmT y, VecmT z) {static_assert(n==3); c[0] = x; c[1] = y; c[2] = z;}$/;"	f	class:Mat
Mat	vectors.hpp	/^    explicit Mat (VecmT x, VecmT y, VecmT z, VecmT w) {static_assert(n==4); c[0] = x; c[1] = y; c[2] = z; c[3] = w;}$/;"	f	class:Mat
Mat	vectors.hpp	/^template <int m, int n, typename T=double> class Mat {$/;"	c
Mat12x12	physics.cpp	/^typedef Mat<12,12> Mat12x12;$/;"	t	file:
Mat2x2	vectors.hpp	/^typedef Mat<2,2> Mat2x2;$/;"	t
Mat2x3	vectors.hpp	/^typedef Mat<2,3> Mat2x3;$/;"	t
Mat3x2	vectors.hpp	/^typedef Mat<3,2> Mat3x2;$/;"	t
Mat3x3	vectors.hpp	/^typedef Mat<3,3> Mat3x3;$/;"	t
Mat3x4	physics.cpp	/^typedef Mat<3,4> Mat3x4;$/;"	t	file:
Mat4x6	physics.cpp	/^typedef Mat<4,6> Mat4x6;$/;"	t	file:
Mat4x9	physics.cpp	/^typedef Mat<4,9> Mat4x9;$/;"	t	file:
Mat6x6	physics.cpp	/^typedef Mat<6,6> Mat6x6;$/;"	t	file:
Mat9x6	physics.cpp	/^typedef Mat<9,6> Mat9x6;$/;"	t	file:
Mat9x9	physics.cpp	/^typedef Mat<9,9> Mat9x9;$/;"	t	file:
MatTransposed	vectors.hpp	/^template <int m, int n, typename T> class MatTransposed : protected Mat<m,n,T> {$/;"	c
Material	cloth.hpp	/^struct Material {$/;"	s
MatmnT	vectors.hpp	149;"	d
MatmnT	vectors.hpp	220;"	d
MatnmT	vectors.hpp	150;"	d
MatnnT	vectors.hpp	151;"	d
MatnnT	vectors.hpp	221;"	d
Mesh	mesh.hpp	/^    Mesh() : ref(0), parent(0), proxy(0) {};$/;"	f	struct:Mesh
Mesh	mesh.hpp	/^struct Mesh {$/;"	s
MeshGrad	constraint.hpp	/^typedef std::vector<MeshGradV> MeshGrad;$/;"	t
MeshGradV	constraint.hpp	/^struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };$/;"	f	struct:MeshGradV
MeshGradV	constraint.hpp	/^struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };$/;"	s
MeshHess	constraint.hpp	/^typedef std::vector<MeshHessV> MeshHess;$/;"	t
MeshHessV	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};$/;"	f	struct:MeshHessV
MeshHessV	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};$/;"	s
MeshSubset	subset.hpp	/^class MeshSubset {$/;"	c
Min	nearobs.cpp	/^    Min (): key(infinity), val() {}$/;"	f	struct:Min
Min	nearobs.cpp	/^template <typename T> struct Min {$/;"	s	file:
Min	proximity.cpp	/^    Min (): key(infinity), val() {}$/;"	f	struct:Min
Min	proximity.cpp	/^template <typename T> struct Min {$/;"	s	file:
Mode	util.hpp	/^	enum Mode { Load = 0, Save, Check };$/;"	g	struct:Serialize
Morph	morph.hpp	/^struct Morph {$/;"	s
Motion	transformation.hpp	/^typedef Spline<Transformation> Motion;$/;"	t
MouseState	display.cpp	/^struct MouseState {$/;"	s	file:
NEAROBS_HPP	nearobs.hpp	28;"	d
NEXT	util.hpp	44;"	d
NLConOpt	optimization.hpp	/^struct NLConOpt { \/\/ nonlinear constrained optimization problem$/;"	s
NLOpt	optimization.hpp	/^struct NLOpt { \/\/ nonlinear optimization problem$/;"	s
NearPoint	nearobs.cpp	/^    NearPoint (double d, const Vec3 &x): d(d), x(x) {}$/;"	f	struct:NearPoint
NearPoint	nearobs.cpp	/^struct NearPoint {$/;"	s	file:
Node	mesh.hpp	/^    Node () : uuid(uuid_src++), sep(0),label(0),flag(0),preserve(false),index(-1),a(0),m(0) {}$/;"	f	struct:Node
Node	mesh.hpp	/^    explicit Node (const Vec3 &y, const Vec3 &x, const Vec3 &v, int label, int flag, $/;"	f	struct:Node
Node	mesh.hpp	/^struct Node {$/;"	s
NodeFlags	mesh.hpp	/^	enum NodeFlags { FlagNone = 0, FlagActive = 1, FlagMayBreak = 2, $/;"	g	struct:Node
NodeHandle	handle.hpp	/^    NodeHandle (): activated(false) {}$/;"	f	struct:NodeHandle
NodeHandle	handle.hpp	/^struct NodeHandle: public Handle {$/;"	s
NormalOpt	collision.cpp	/^    NormalOpt (): zone(NULL), inv_m(0) {nvar = ncon = 0;}$/;"	f	struct:NormalOpt
NormalOpt	collision.cpp	/^    NormalOpt (ImpactZone *zone): zone(zone), inv_m(0) {$/;"	f	struct:NormalOpt
NormalOpt	collision.cpp	/^struct NormalOpt: public NLConOpt {$/;"	s	file:
OBSTACLE_HPP	obstacle.hpp	28;"	d
OPENGL_HPP	opengl.hpp	28;"	d
OPTIMIZATION_HPP	optimization.hpp	28;"	d
Obstacle	obstacle.hpp	/^    Obstacle (): start_time(0), end_time(infinity), activated(false) {}$/;"	f	struct:Obstacle
Obstacle	obstacle.hpp	/^struct Obstacle {$/;"	s
OptOptions	optimization.hpp	/^    OptOptions (): _max_iter(100), _eps_x(1e-6), _eps_f(1e-12), _eps_g(1e-6) {}$/;"	f	struct:OptOptions
OptOptions	optimization.hpp	/^struct OptOptions {$/;"	s
PARSE_MAGIC	conf.cpp	641;"	d	file:
PARSE_MAGIC	conf.cpp	657;"	d	file:
PHYSICS_HPP	physics.hpp	28;"	d
PLASTICITY_HPP	plasticity.hpp	28;"	d
POPFILTER_HPP	popfilter.hpp	28;"	d
PREV	util.hpp	45;"	d
PROXIMITY_HPP	proximity.hpp	28;"	d
PROXY_HPP	proxy.hpp	28;"	d
PS	geometry.hpp	/^enum Space {MS, PS, WS}; \/\/ material space, plastic space, world space$/;"	e	enum:Space
Pane	display.hpp	/^    Pane (bool enable): lat(0), lon(0), offset(0), scale(0.5), enabled(enable), initialized(false) {}$/;"	f	struct:Pane
Pane	display.hpp	/^struct Pane {$/;"	s
Physics	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon2
Plane	mesh.hpp	/^    Plane() {}$/;"	f	struct:Plane
Plane	mesh.hpp	/^    Plane(const Vec3& x0, const Vec3& n) : x0(x0), n(n) {}$/;"	f	struct:Plane
Plane	mesh.hpp	/^struct Plane {$/;"	s
Plasticity	simulation.hpp	/^          PopFilter, Plasticity, Fracture, nModules};$/;"	e	enum:Simulation::__anon2
PlasticityStash	remesh.cpp	/^    PlasticityStash (vector<Face*> &faces, vector<Edge*> &edges)$/;"	f	struct:PlasticityStash
PlasticityStash	remesh.cpp	/^struct PlasticityStash {$/;"	s	file:
Point	spline.hpp	/^    struct Point {double t; T x, v;};$/;"	s	class:Spline
PopFilter	simulation.hpp	/^          PopFilter, Plasticity, Fracture, nModules};$/;"	e	enum:Simulation::__anon2
PopOpt	popfilter.cpp	/^    PopOpt (Cloth &cloth, const vector<Constraint*> &cons):$/;"	f	struct:PopOpt
PopOpt	popfilter.cpp	/^struct PopOpt: public NLOpt {$/;"	s	file:
Proximity	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon2
Q	vectors.hpp	/^    Mat<n,n> Q;$/;"	m	struct:Eig
Quaternion	transformation.hpp	/^struct Quaternion {$/;"	s
REFERENCESHAPE_HPP	referenceshape.hpp	2;"	d
REMESH_HPP	remesh.hpp	28;"	d
REPORT	util.hpp	200;"	d
REPORT_ARRAY	util.hpp	202;"	d
ROTATE	display.cpp	/^    enum {ROTATE, TRANSLATE, SCALE} func;$/;"	e	enum:MouseState::__anon1	file:
RUNPHYSICS_HPP	runphysics.hpp	28;"	d
Range	conf.cpp	/^    Range (double &min, double &max): min(min), max(max) {}$/;"	f	struct:Range
Range	conf.cpp	/^struct Range {$/;"	s	file:
ReferenceLinear	referenceshape.cpp	/^ReferenceLinear::ReferenceLinear(const Mesh& mesh) {    $/;"	f	class:ReferenceLinear
ReferenceLinear	referenceshape.hpp	/^class ReferenceLinear : public ReferenceShape {$/;"	c
ReferenceMesh	referenceshape.cpp	/^ReferenceMesh::ReferenceMesh(const Mesh& mesh, const string& filename) {  $/;"	f	class:ReferenceMesh
ReferenceMesh	referenceshape.hpp	/^class ReferenceMesh : public ReferenceShape {$/;"	c
ReferenceShape	referenceshape.hpp	/^class ReferenceShape {$/;"	c
ReferenceSphere	referenceshape.cpp	/^ReferenceSphere::ReferenceSphere(const Mesh& mesh) {$/;"	f	class:ReferenceSphere
ReferenceSphere	referenceshape.cpp	/^ReferenceSphere::ReferenceSphere(const Vec3& _center, double _radius) : center(_center), radius(_radius) {$/;"	f	class:ReferenceSphere
ReferenceSphere	referenceshape.hpp	/^class ReferenceSphere : public ReferenceShape {$/;"	c
RemeshOp	remesh.hpp	/^struct RemeshOp {$/;"	s
Remeshing	cloth.hpp	/^struct Remeshing {$/;"	s
Remeshing	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon2
SCALE	display.cpp	/^    enum {ROTATE, TRANSLATE, SCALE} func;$/;"	e	enum:MouseState::__anon1	file:
SEPARATEOBS_HPP	separateobs.hpp	28;"	d
SEPARATE_HPP	separate.hpp	28;"	d
SEPSTRENGTH_HPP	sepstrength.hpp	28;"	d
SIMULATION_HPP	simulation.hpp	28;"	d
SLOpt	strainlimiting.cpp	/^    SLOpt (vector<Mesh*> &meshes, const vector<StrainLimit> &strain_limits,$/;"	f	struct:SLOpt
SLOpt	strainlimiting.cpp	/^struct SLOpt: public NLConOpt {$/;"	s	file:
SO	separateobs.cpp	/^namespace SO {$/;"	n	file:
SPARSE_HPP	sparse.hpp	28;"	d
SPLINE_HPP	spline.hpp	28;"	d
STRAINLIMITING_HPP	strainlimiting.hpp	28;"	d
SUBSET_HPP	subset.hpp	28;"	d
SUPPORT_RINGS	breaking.cpp	/^const int SUPPORT_RINGS = 2;$/;"	v
SVD	vectors.hpp	/^template <int m, int n> struct SVD {$/;"	s
Save	util.hpp	/^	enum Mode { Load = 0, Save, Check };$/;"	e	enum:Serialize::Mode
Separation	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon2
SeparationOpt	separateobs.cpp	/^    SeparationOpt (const vector<Ixn> &ixns): ixns(ixns), inv_m(0) {$/;"	f	struct:SO::SeparationOpt
SeparationOpt	separateobs.cpp	/^struct SeparationOpt: public NLConOpt {$/;"	s	namespace:SO	file:
Serialize	util.hpp	/^struct Serialize {$/;"	s
Simulation	simulation.hpp	/^struct Simulation {$/;"	s
SoftHandle	handle.hpp	/^struct SoftHandle: public Handle {$/;"	s
SpMat	sparse.hpp	/^    SpMat (): m(0), n(0), rows() {}$/;"	f	struct:SpMat
SpMat	sparse.hpp	/^    explicit SpMat (int m, int n): m(m), n(n), rows(m) {}$/;"	f	struct:SpMat
SpMat	sparse.hpp	/^template <typename T> struct SpMat {$/;"	s
SpVec	sparse.hpp	/^template <typename T> struct SpVec {$/;"	s
Sp_bend	mesh.hpp	/^    Mat3x3 Sp_bend; \/\/ plastic bending strain$/;"	m	struct:Face
Sp_str	mesh.hpp	/^    Mat3x3 Sp_str; \/\/ plastic stretching$/;"	m	struct:Face
Sp_str	remesh.cpp	/^    vector<Mat3x3> Sp_str;$/;"	m	struct:PlasticityStash	file:
Space	geometry.hpp	/^enum Space {MS, PS, WS}; \/\/ material space, plastic space, world space$/;"	g
Spline	spline.hpp	/^class Spline {$/;"	c
SplitNode	sepstrength.hpp	/^	SplitNode(Node* node) : node(node),sep(0) { faces[0] = faces[1] = NULL; normal[0] = normal[1]= Vec3(0); }$/;"	f	struct:SplitNode
SplitNode	sepstrength.hpp	/^struct SplitNode {$/;"	s
Stats	util.hpp	/^    Stats (): sum(0) {}$/;"	f	struct:Stats
Stats	util.hpp	/^struct Stats {$/;"	s
StrainLimit	strainlimiting.hpp	/^    StrainLimit() : min(1), max(1) {}$/;"	f	struct:StrainLimit
StrainLimit	strainlimiting.hpp	/^    StrainLimit(double min, double max) : min(min), max(max) {}$/;"	f	struct:StrainLimit
StrainLimit	strainlimiting.hpp	/^struct StrainLimit {$/;"	s
StrainLimiting	simulation.hpp	/^    enum {Proximity, Physics, StrainLimiting, Collision, Remeshing, Separation,$/;"	e	enum:Simulation::__anon2
StretchingData	dde.hpp	/^struct StretchingData {Vec4 d[2][5];};$/;"	s
StretchingSamples	dde.hpp	/^struct StretchingSamples {Vec4 s[40][40][40];};$/;"	s
TAUCS_HPP	taucs.hpp	28;"	d
TENSORMAX_HPP	tensormax.hpp	28;"	d
TRANSFORMATION_HPP	transformation.hpp	28;"	d
TRANSLATE	display.cpp	/^    enum {ROTATE, TRANSLATE, SCALE} func;$/;"	e	enum:MouseState::__anon1	file:
Timer	timer.cpp	/^Timer::Timer (): last(0), total(0) {$/;"	f	class:Timer
Timer	timer.hpp	/^struct Timer {$/;"	s
Transformation	transformation.cpp	/^Transformation::Transformation(double factor) {$/;"	f	class:Transformation
Transformation	transformation.hpp	/^struct Transformation {$/;"	s
Type	collision.cpp	/^    enum Type {VF, EE} type;$/;"	g	struct:Impact	file:
U	vectors.hpp	/^    Mat<m,m> U;$/;"	m	struct:SVD
UTIL_HPP	util.hpp	28;"	d
UnionFind	separate.cpp	/^    UnionFind (size_t n): parent(n), rank(n, 0) {$/;"	f	struct:UnionFind
UnionFind	separate.cpp	/^struct UnionFind {$/;"	s	file:
VECTORS_HPP	vectors.hpp	28;"	d
VEC_CMP	util.hpp	149;"	d
VEC_CMP	util.hpp	160;"	d
VF	collision.cpp	/^    enum Type {VF, EE} type;$/;"	e	enum:Impact::Type	file:
Vec	vectors.hpp	/^    Vec () {for (int i = 0; i < n; i++) c[i] = 0;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T v0, T v1, T v2, T v3, T v4, T v5) {static_assert(n==6); c[0] = v0; c[1] = v1; c[2] = v2; c[3] = v3; c[4] = v4; c[5] = v5; }$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x) {for (int i = 0; i < n; i++) c[i] = x;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x, T y) {static_assert(n==2); c[0] = x; c[1] = y;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x, T y, T z) {static_assert(n==3); c[0] = x; c[1] = y; c[2] = z;}$/;"	f	class:Vec
Vec	vectors.hpp	/^    explicit Vec (T x, T y, T z, T w) {static_assert(n==4); c[0] = x; c[1] = y; c[2] = z; c[3] = w;}$/;"	f	class:Vec
Vec	vectors.hpp	/^template <int n, typename T=double> class Vec {$/;"	c
Vec12	physics.cpp	/^typedef Vec<12> Vec12;$/;"	t	file:
Vec2	vectors.hpp	/^typedef Vec<2> Vec2;$/;"	t
Vec3	vectors.hpp	/^typedef Vec<3> Vec3;$/;"	t
Vec4	dde.hpp	/^typedef Vec<4> Vec4;$/;"	t
Vec4	mot_parser.hpp	/^typedef Vec<4> Vec4;$/;"	t
Vec9	physics.cpp	/^typedef Vec<9> Vec9;$/;"	t	file:
VecmT	vectors.hpp	152;"	d
VecmT	vectors.hpp	222;"	d
VecnT	vectors.hpp	143;"	d
VecnT	vectors.hpp	153;"	d
VecnT	vectors.hpp	223;"	d
VecnT	vectors.hpp	76;"	d
Velocity	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	s	file:
Vert	mesh.hpp	/^    Vert () : node(0),index(-1) {}$/;"	f	struct:Vert
Vert	mesh.hpp	/^    explicit Vert (const Vec3 &u):$/;"	f	struct:Vert
Vert	mesh.hpp	/^struct Vert {$/;"	s
Vt	vectors.hpp	/^    Mat<n,n> Vt;$/;"	m	struct:SVD
WINPORT_HPP	winport.hpp	28;"	d
WS	geometry.hpp	/^enum Space {MS, PS, WS}; \/\/ material space, plastic space, world space$/;"	e	enum:Space
Weights	morph.hpp	/^    typedef std::vector<double> Weights;$/;"	t	struct:Morph
Wind	simulation.hpp	/^struct Wind {$/;"	s
_USE_MATH_DEFINES	winport.hpp	40;"	d
__TIMER_H	timer.hpp	29;"	d
__align	vectors.hpp	43;"	d
__align	vectors.hpp	48;"	d
_active	bvh.hpp	/^    bool _active;$/;"	m	class:DeformBVHNode
_box	bvh.hpp	/^	BOX _box;$/;"	m	class:DeformBVHNode
_ccd	bvh.hpp	/^    bool _ccd;$/;"	m	class:DeformBVHTree
_dist	bvh.hpp	/^	float _dist[18];$/;"	m	class:kDOP18
_eps_f	optimization.hpp	/^    double _eps_x, _eps_f, _eps_g;$/;"	m	struct:OptOptions
_eps_g	optimization.hpp	/^    double _eps_x, _eps_f, _eps_g;$/;"	m	struct:OptOptions
_eps_x	optimization.hpp	/^    double _eps_x, _eps_f, _eps_g;$/;"	m	struct:OptOptions
_face	bvh.hpp	/^	Face *_face;$/;"	m	class:DeformBVHNode
_left	bvh.hpp	/^	DeformBVHNode *_left;$/;"	m	class:DeformBVHNode
_max_iter	optimization.hpp	/^    int _max_iter;$/;"	m	struct:OptOptions
_mdl	bvh.hpp	/^	DeformModel		*_mdl;$/;"	m	class:DeformBVHTree
_p	bvh.cpp	/^	float _p;$/;"	m	class:aap	file:
_parent	bvh.hpp	/^	DeformBVHNode *_parent;$/;"	m	class:DeformBVHNode
_right	bvh.hpp	/^	DeformBVHNode *_right;$/;"	m	class:DeformBVHNode
_root	bvh.hpp	/^	DeformBVHNode	*_root;$/;"	m	class:DeformBVHTree
_xyz	bvh.cpp	/^	char _xyz;$/;"	m	class:aap	file:
a	constraint.hpp	/^    double a; \/\/ area$/;"	m	struct:IneqCon
a	mesh.hpp	/^    double a, m; \/\/ area, mass$/;"	m	struct:Face
a	mesh.hpp	/^    double a, m; \/\/ area, mass$/;"	m	struct:Node
a0	popfilter.cpp	/^    vector<Vec3> x0, a0;$/;"	m	struct:PopOpt	file:
aap	bvh.cpp	/^	FORCEINLINE aap(const BOX &total) {$/;"	f	class:aap
aap	bvh.cpp	/^class aap {$/;"	c	file:
acceleration	mesh.hpp	/^    Vec3 acceleration;$/;"	m	struct:Node
activate_nodes	mesh.cpp	/^void activate_nodes(vector<Node*>& nodes) {$/;"	f
activated	handle.hpp	/^    bool activated;$/;"	m	struct:NodeHandle
activated	obstacle.hpp	/^    bool activated;$/;"	m	struct:Obstacle
active	collision.cpp	/^    bool active;$/;"	m	struct:ImpactZone	file:
active	display.cpp	/^struct DisplayMode { string name; double scale; bool active; };$/;"	m	struct:DisplayMode	file:
active	handle.hpp	/^    bool active (double t) {return t >= start_time && t <= end_time;}$/;"	f	struct:Handle
active	mesh.hpp	/^    inline bool active() const { return flag & FlagActive; }$/;"	f	struct:Node
active_nodes	subset.hpp	/^	std::vector<Node*> active_nodes;$/;"	m	class:MeshSubset
add	display.hpp	/^	static void add(Edge* e, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,e,0,c,Vec3(0))); }$/;"	f	struct:Annotation
add	display.hpp	/^	static void add(Face* f, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(f,0,0,c,Vec3(0))); }$/;"	f	struct:Annotation
add	display.hpp	/^	static void add(Node* n, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,0,n,c,Vec3(0))); }$/;"	f	struct:Annotation
add	display.hpp	/^	static void add(Vec3 pos, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,0,0,c,pos)); }$/;"	f	struct:Annotation
add	display.hpp	/^	static void add(Vec3 pos, Vec3 dir, Vec3 c = Vec3(1,0,0)) { list.push_back(Annotation(0,0,0,c,pos,dir)); }$/;"	f	struct:Annotation
add	lsnewton.cpp	/^static void add (vector<double> &v, double a, const vector<double> &x,$/;"	f	file:
add	mesh.cpp	/^void Mesh::add (Edge *edge) {$/;"	f	class:Mesh
add	mesh.cpp	/^void Mesh::add (Face *face) {$/;"	f	class:Mesh
add	mesh.cpp	/^void Mesh::add (Node *node) {$/;"	f	class:Mesh
add	mesh.cpp	/^void Mesh::add (Vert *vert) {$/;"	f	class:Mesh
add	nearobs.cpp	/^    void add (double key, T val) {$/;"	f	struct:Min
add	proximity.cpp	/^    void add (double key, T val) {$/;"	f	struct:Min
add	trustregion.cpp	/^static void add (vector<double> &v, const vector<double> &x,$/;"	f	file:
add	trustregion.cpp	/^static void add (vector<double> &v, double a, const vector<double> &x,$/;"	f	file:
add	util.cpp	/^void Stats::add (double x) {$/;"	f	class:Stats
add_all	remesh.cpp	/^template <class T> static void add_all(const vector<T>& a, Mesh& m) { for(size_t i=0; i<a.size(); i++) m.add(a[i]); }$/;"	f	file:
add_constraint_forces	physics.cpp	/^void add_constraint_forces (const vector<Constraint*> &cons,$/;"	f
add_edges_if_needed	mesh.cpp	/^void add_edges_if_needed (Mesh &mesh, const Face *face) {$/;"	f
add_external_forces	physics.cpp	/^void add_external_forces (const vector<Node*>& nodes, const vector<Face*>& faces, const Vec3 &gravity,$/;"	f
add_forces	handle.cpp	/^void SoftHandle::add_forces(double t, vector<Vec3> &fext, vector<Mat3x3>& Jext) {$/;"	f	class:SoftHandle
add_forces	handle.hpp	/^    virtual void add_forces(double t, std::vector<Vec3> &fext, std::vector<Mat3x3>& Jext) {}$/;"	f	struct:Handle
add_friction_forces	physics.cpp	/^void add_friction_forces (const vector<Constraint*> cons,$/;"	f
add_gradient	separate.cpp	/^void add_gradient (const Face *face0, const Edge *edge0, const Face *face1,$/;"	f
add_impacts	collision.cpp	/^void add_impacts (const vector<Impact> &impacts, vector<ImpactZone*> &zones) {$/;"	f
add_internal_forces	physics.cpp	/^void add_internal_forces (const vector<Face*>& faces, const vector<Edge*>& edges,$/;"	f
add_jitter	magic.hpp	/^    bool add_jitter;$/;"	m	struct:Magic
add_jitter	simulation.cpp	/^void add_jitter (Simulation& sim) { $/;"	f
add_morph_forces	physics.cpp	/^void add_morph_forces (const Cloth &cloth, const Morph &morph, double t,$/;"	f
add_position_constraints	handle.cpp	/^void add_position_constraints (const Node *node, const Vec3 &x, double stiff,$/;"	f
add_proximity	proximity.cpp	/^void add_proximity (const Edge *edge0, const Edge *edge1) {$/;"	f
add_proximity	proximity.cpp	/^void add_proximity (const Node *node, const Face *face) {$/;"	f
add_proximity	proximity.cpp	/^void add_proximity(Node *node, Edge* edge) {$/;"	f
add_strain_row	strainlimiting.cpp	/^void add_strain_row (const Mat3x3 &sg, const Face *face,$/;"	f
add_submat	optimization.hpp	/^inline void add_submat (SpMat<double> &A, int i, int j, const Mat3x3 &Aij) {$/;"	f
add_submat	physics.cpp	/^template <int m> void add_submat (const Mat<m*3,m*3> &Asub, const Vec<m,int> &ix, SpMat<Mat3x3> &A) {$/;"	f
add_subvec	optimization.hpp	/^inline void add_subvec (double *x, int i, const Vec3 &xi) {$/;"	f
add_subvec	optimization.hpp	/^template <int n> void add_subvec (double *x, int i, const Vec<n> &xi) {$/;"	f
add_subvec	physics.cpp	/^template <int m> void add_subvec (const Vec<m*3> &bsub, const Vec<m,int> &ix, vector<Vec3> &b) {$/;"	f
added_edges	remesh.hpp	/^    std::vector<Edge*> added_edges, removed_edges;$/;"	m	struct:RemeshOp
added_faces	remesh.hpp	/^    std::vector<Face*> added_faces, removed_faces;$/;"	m	struct:RemeshOp
added_nodes	remesh.hpp	/^    std::vector<Node*> added_nodes, removed_nodes;$/;"	m	struct:RemeshOp
added_verts	remesh.hpp	/^    std::vector<Vert*> added_verts, removed_verts;$/;"	m	struct:RemeshOp
adj_face	mesh.hpp	/^inline Face *adj_face (const Face* face0, int num) {$/;"	f
adjacent	separate.cpp	/^bool adjacent (const Face *face0, const Face *face1) {$/;"	f
adjacent	separateobs.cpp	/^bool adjacent (const Face *face0, const Face *face1) {$/;"	f	namespace:SO
adjacent_vert	dynamicremesh.cpp	/^Vert *adjacent_vert (const Node *node, const Vert *vert) {$/;"	f
adje	mesh.hpp	/^    Edge *adje[3]; \/\/ adjacent edges$/;"	m	struct:Face
adje	mesh.hpp	/^    std::vector<Edge*> adje; \/\/ adjacent edges$/;"	m	struct:Node
adjf	mesh.hpp	/^    Face *adjf[2]; \/\/ adjacent faces$/;"	m	struct:Edge
adjf	mesh.hpp	/^    std::vector<Face*> adjf; \/\/ adjacent faces$/;"	m	struct:Vert
advance_frame	simulation.cpp	/^void advance_frame (Simulation &sim) {$/;"	f
advance_step	simulation.cpp	/^void advance_step (Simulation &sim) {	$/;"	f
alglib_linear_solve	taucs.cpp	/^vector<double> alglib_linear_solve(const SpMat<double>& A, const vector<double>& b) {$/;"	f
alglib_linear_solve_vec	taucs.cpp	/^vector<Vec<C> > alglib_linear_solve_vec(const SpMat<Mat<C,C> >& A, const vector<Vec<C> >& b) {$/;"	f
aligned_free	vectors.hpp	/^inline void aligned_free(void *ptr)    { _aligned_free(ptr); }$/;"	f
aligned_free	vectors.hpp	/^inline void aligned_free(void *ptr)    { free(ptr); }$/;"	f
alt_bending	cloth.hpp	/^    double alt_stretching, alt_bending, alt_poisson; \/\/ alternative material model$/;"	m	struct:Material
alt_poisson	cloth.hpp	/^    double alt_stretching, alt_bending, alt_poisson; \/\/ alternative material model$/;"	m	struct:Material
alt_stretching	cloth.hpp	/^    double alt_stretching, alt_bending, alt_poisson; \/\/ alternative material model$/;"	m	struct:Material
ambient_light	display.cpp	/^void ambient_light (const Vec3 &a) {$/;"	f
angle	dynamicremesh.cpp	/^double angle (const Vec3 &n1, const Vec3 &n2) {$/;"	f
angle	io.cpp	/^static double angle (const Vec3 &x0, const Vec3 &x1, const Vec3 &x2) {$/;"	f	file:
angle0	sepstrength.cpp	/^	double angle0, angle1;$/;"	m	struct:FanPrecomp	file:
angle1	sepstrength.cpp	/^	double angle0, angle1;$/;"	m	struct:FanPrecomp	file:
any_nearly_invalid	dynamicremesh.cpp	/^bool any_nearly_invalid (const vector<Edge*> edges) {$/;"	f
apollonius	tensormax.cpp	/^Disk apollonius (const Disk &disk1, const Disk &disk2, const Disk &disk3) {$/;"	f
append	util.hpp	/^inline void append (std::vector<T> &xs, const std::vector<T> &ys) {$/;"	f
append_frame	mot_parser.cpp	/^void append_frame(BodyVector &bodies, size_t body_index, const BodyFrame& bf) {$/;"	f
apply	morph.cpp	/^void apply (const Morph &morph, double t) {$/;"	f
apply	remesh.cpp	/^    void apply (vector<Face*> &faces, vector<Edge*> &edges) {$/;"	f	struct:PlasticityStash
apply	remesh.cpp	/^void RemeshOp::apply (Mesh &mesh) const {$/;"	f	class:RemeshOp
apply	transformation.cpp	/^Vec3 Transformation::apply (const Vec3 &x) const {$/;"	f	class:Transformation
apply_dtrans	transformation.cpp	/^Vec3 apply_dtrans (const DTransformation &dtrans, const Vec3 &x0, Vec3 *vel) {$/;"	f
apply_dtrans_vec	transformation.cpp	/^Vec3 apply_dtrans_vec (const DTransformation &dtrans, const Vec3 &v0) {$/;"	f
apply_inelastic_projection	collision.cpp	/^void apply_inelastic_projection (ImpactZone *zone,$/;"	f
apply_pop_filter	popfilter.cpp	/^void apply_pop_filter (Cloth &cloth, const vector<Constraint*> &cons,$/;"	f
apply_transformation	mesh.cpp	/^void apply_transformation (Mesh& mesh, const Transformation& tr) {$/;"	f
apply_transformation_onto	mesh.cpp	/^void apply_transformation_onto (const Mesh &start_state, Mesh &onto,$/;"	f
apply_vec	transformation.cpp	/^Vec3 Transformation::apply_vec (const Vec3 &v) const {$/;"	f	class:Transformation
apply_velocity	conf.cpp	/^void apply_velocity (Mesh &mesh, const Velocity &vel) {$/;"	f
apply_view	display.cpp	/^void apply_view (const Pane &view) {$/;"	f
area	geometry.hpp	/^inline double area (const Face* face) { return area(face->v[0]->u, face->v[1]->u, face->v[2]->u); }$/;"	f
area	geometry.hpp	/^inline double area (const Vec3& u0, const Vec3& u1, const Vec3& u2) { return 0.5*norm(cross(u1-u0,u2-u0)); }$/;"	f
area_cached	proximity.cpp	/^double area_cached (const Edge *edge) {$/;"	f
area_cached	proximity.cpp	/^double area_cached (const Face *face) {$/;"	f
area_cached	proximity.cpp	/^double area_cached (const Node *node) {$/;"	f
aspect	geometry.cpp	/^double aspect (const Vec3& u0, const Vec3& u1, const Vec3& u2) {$/;"	f
aspect	geometry.hpp	/^inline double aspect (const Face* face) { return aspect(face->v[0]->u, face->v[1]->u, face->v[2]->u); }$/;"	f
aspect_min	cloth.hpp	/^    double aspect_min; \/\/ aspect ratio control$/;"	m	struct:Remeshing
aspect_ratio	display.cpp	/^double aspect_ratio () {$/;"	f
auglag_value_and_grad	auglag.cpp	/^static void auglag_value_and_grad (const real_1d_array &x, double &value,$/;"	f	file:
augmented_lagrangian_method	auglag.cpp	/^void augmented_lagrangian_method (const NLConOpt &problem, OptOptions opt,$/;"	f
axis	separate.cpp	/^    size_t axis;$/;"	m	struct:cmpOneAxis	file:
b0	separateobs.cpp	/^    Bary b0, b1;$/;"	m	struct:SO::Ixn	file:
b1	separateobs.cpp	/^    Bary b0, b1;$/;"	m	struct:SO::Ixn	file:
b_md	tensormax.cpp	/^Disk b_md (const vector<Disk> &R) {$/;"	f
b_minidisk	tensormax.cpp	/^Disk b_minidisk (const vector<Disk> &P, const vector<Disk> &R) {$/;"	f
barycentric_coords	separate.cpp	/^Bary barycentric_coords (const Vec3 &x, const Face *face) {$/;"	f
barycentric_weights	physics.cpp	/^Vec2 barycentric_weights (const Vec3 &x, const Vec3 &a, const Vec3 &b) {$/;"	f
base_mesh	obstacle.hpp	/^    Mesh base_mesh;$/;"	m	struct:Obstacle
bending_coeff	physics.cpp	/^double bending_coeff(const Edge* edge, double theta) {$/;"	f
bending_energy	physics.cpp	/^double bending_energy (const Edge *edge) {$/;"	f
bending_force	physics.cpp	/^pair<Mat12x12,Vec12> bending_force (const Edge *edge) {$/;"	f
bending_stiffness	dde.cpp	/^double bending_stiffness (const Edge *edge, int side,$/;"	f
blend	morph.cpp	/^Vec3 blend (const vector<Mesh> &targets, const vector<double> &w,$/;"	f
blend_with_previous	obstacle.cpp	/^void Obstacle::blend_with_previous (double t, double dt, double blend) {$/;"	f	class:Obstacle
blockdiag	blockvectors.hpp	/^template <int bn, int m, int n, typename T> Mat<m*bn,n*bn,T> blockdiag (const Mat<m,n,T> &A) {$/;"	f
body_vector_to_transforms	mot_parser.cpp	/^vector<vector<Transformation> > body_vector_to_transforms(BodyVector& bodies) {$/;"	f
bodyframe_to_transformation	mot_parser.cpp	/^Transformation bodyframe_to_transformation(const BodyFrame& bodyFrame) {$/;"	f
box	bvh.cpp	/^DeformBVHTree::box()$/;"	f	class:DeformBVHTree
break_node	breaking.cpp	/^bool break_node(SplitNode& split, MeshSubset& subset) {$/;"	f
build_cubic_spline	mot_parser.cpp	/^Spline<Transformation> build_cubic_spline($/;"	f
build_face_normal_lookup	separateobs.cpp	/^void build_face_normal_lookup(map<const Face*,Vec3>& nmap, const vector<Mesh*>& meshes) {$/;"	f	namespace:SO
build_node_lookup	util.cpp	/^void build_node_lookup(map<const Node*,Vec3>& nodemap, const vector<Mesh*>& meshes) {$/;"	f
c	handle.hpp	/^    double c; \/\/ circumference$/;"	m	struct:CircleHandle
c	tensormax.cpp	/^    Vec2 c;$/;"	m	struct:Disk	file:
c	vectors.hpp	/^    VecmT c[n];$/;"	m	class:Mat
c	vectors.hpp	/^  __align(32) T c[n%4? 4*(1+n\/4): n];$/;"	m	class:Vec
can_collapse	dynamicremesh.cpp	/^bool can_collapse (Remeshing& remeshing, const Edge *edge, int i) {$/;"	f
cancel	remesh.cpp	/^void RemeshOp::cancel() {$/;"	f	class:RemeshOp
cb	lsnewton.cpp	/^inline double cb (double x) {return x*x*x;}$/;"	f
center	bvh.hpp	/^	FORCEINLINE float center(int i) const {$/;"	f	class:kDOP18
center	bvh.hpp	/^	FORCEINLINE vec3f center() const { $/;"	f	class:kDOP18
center	display.hpp	/^    Vec3 center;$/;"	m	struct:Pane
center	handle.hpp	/^    Vec3 center;$/;"	m	struct:SoftHandle
center	proxy.hpp	/^    Node center;$/;"	m	class:FloorProxy
center	referenceshape.hpp	/^    Vec3 center;$/;"	m	class:ReferenceSphere
check	mesh.cpp	/^template <typename T1, typename T2> void check (const T1 *p1, const T2 *p2,$/;"	f
check	util.hpp	/^	bool check() { return mode == Check; }	$/;"	f	struct:Serialize
check_that_contents_are_sane	mesh.cpp	/^bool check_that_contents_are_sane (const Mesh &mesh) {$/;"	f
check_that_pointers_are_sane	mesh.cpp	/^bool check_that_pointers_are_sane (const Mesh &mesh) {$/;"	f
clamp	util.hpp	/^template <typename T> T clamp (const T &x, const T &a, const T &b) {$/;"	f
clamp_violation	auglag.cpp	/^inline double clamp_violation (double x, int sign) {$/;"	f
clean_up_quaternions	transformation.cpp	/^void clean_up_quaternions (Motion &motion) {$/;"	f
clear_flag	subset.cpp	/^void MeshSubset::clear_flag(int flag) {$/;"	f	class:MeshSubset
clip_edge_to_face	separate.cpp	/^EdgeClipping clip_edge_to_face (const Edge *edge, const Face *face) {$/;"	f
clone	proxy.cpp	/^CollisionProxy* FloorProxy::clone(Mesh& mesh) {$/;"	f	class:FloorProxy
closest_point	referenceshape.cpp	/^Vec3 ReferenceLinear::closest_point(const Vec3& p) {$/;"	f	class:ReferenceLinear
closest_point	referenceshape.cpp	/^Vec3 ReferenceMesh::closest_point(const Vec3& p) {$/;"	f	class:ReferenceMesh
closest_point	referenceshape.cpp	/^Vec3 ReferenceSphere::closest_point(const Vec3& p) {$/;"	f	class:ReferenceSphere
cloth	plasticity.cpp	/^    Cloth &cloth;$/;"	m	struct:EmbedOpt	file:
cloth	popfilter.cpp	/^    Cloth &cloth;$/;"	m	struct:PopOpt	file:
cloth_meshes	simulation.hpp	/^    std::vector<Mesh*> cloth_meshes, obstacle_meshes;$/;"	m	struct:Simulation
cloths	simulation.hpp	/^    std::vector<Cloth> cloths;$/;"	m	struct:Simulation
cmpOneAxis	separate.cpp	/^    cmpOneAxis(size_t axis)$/;"	f	struct:cmpOneAxis
cmpOneAxis	separate.cpp	/^struct cmpOneAxis {$/;"	s	file:
col	vectors.hpp	/^    inline VecmT &col (int j) {return c[j];}$/;"	f	class:Mat
col	vectors.hpp	/^    inline const VecmT &col (int j) const {return c[j];}$/;"	f	class:Mat
collapse_edge	remesh.cpp	/^RemeshOp collapse_edge (Edge* edge, int i) {$/;"	f
collect_leaves	collisionutil.cpp	/^void collect_leaves (BVHNode *node, map<const Face*,BVHNode*> &leaves) {$/;"	f
collect_upper_nodes	collisionutil.cpp	/^vector<BVHNode*> collect_upper_nodes (const vector<AccelStruct*> &accs,$/;"	f
collision	simulation.cpp	/^                 collision = Simulation::Collision,$/;"	v	file:
collision_response	collision.cpp	/^void collision_response (vector<Mesh*> &meshes, const vector<Constraint*> &cons,$/;"	f
collision_step	simulation.cpp	/^void collision_step (Simulation &sim) {$/;"	f
collision_stiffness	magic.hpp	/^    double handle_stiffness, collision_stiffness;$/;"	m	struct:Magic
collision_test	collision.cpp	/^bool collision_test (Impact::Type type, const Node *node0, const Node *node1,$/;"	f
colmat	physics.cpp	/^template <int m> Mat<m,1> colmat (const Vec<m> &v) {$/;"	f
color	display.cpp	/^void color (const Vec3 &x) {$/;"	f
color	display.hpp	/^	Vec3 color;$/;"	m	struct:Annotation
combine_tensors	magic.hpp	/^    bool combine_tensors;$/;"	m	struct:Magic
complain	conf.cpp	/^void complain (const Json::Value &json, const string &expected) {$/;"	f
compression_metric	dynamicremesh.cpp	/^Mat2x2 compression_metric (const Face* face, const Mat3x3 &S2, const Mat3x2& UV, double c) {$/;"	f
compute_coplanar	separate.cpp	/^double compute_coplanar (const Face *face0, const Edge *edge0,$/;"	f
compute_face_sizing	dynamicremesh.cpp	/^Mat3x3 compute_face_sizing (Remeshing& remeshing, const Face *face, const map<Node*,Plane> &planes,$/;"	f
compute_length_and_gradient	separate.cpp	/^void compute_length_and_gradient (Ixn &ixn) {$/;"	f
compute_material	cloth.cpp	/^void compute_material (Material& mat, double Y) {$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (Face* face) {$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (Mesh &mesh) {$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (Node* node) {$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (vector<Face*>& faces) {$/;"	f
compute_ms_data	mesh.cpp	/^void compute_ms_data (vector<Node*>& nodes) {$/;"	f
compute_sigma	sepstrength.cpp	/^Mat3x3 compute_sigma(const Face* face) {\/*$/;"	f
compute_ws_data	mesh.cpp	/^void compute_ws_data (Face* face) {$/;"	f
compute_ws_data	mesh.cpp	/^void compute_ws_data (Mesh &mesh) {$/;"	f
compute_ws_data	mesh.cpp	/^void compute_ws_data (Node* node) {$/;"	f
compute_ws_data	mesh.cpp	/^void compute_ws_data (vector<Face*>& faces) {$/;"	f
compute_ws_data	mesh.cpp	/^void compute_ws_data (vector<Node*>& nodes) {$/;"	f
con_grad	collision.cpp	/^void NormalOpt::con_grad (const double *x, int j, double factor,$/;"	f	class:NormalOpt
con_grad	separateobs.cpp	/^void SeparationOpt::con_grad (const double *x, int j, double factor,$/;"	f	class:SO::SeparationOpt
con_grad	strainlimiting.cpp	/^void SLOpt::con_grad (const double *x, int j, double factor,$/;"	f	class:SLOpt
conflict	collision.cpp	/^bool conflict (const Impact &i0, const Impact &i1) {$/;"	f
connect	mesh.cpp	/^void connect (Vert *vert, Node *node) {$/;"	f
connected_components	separate.cpp	/^vector< vector<Node*> > connected_components (const vector<Ixn> &ixns) {$/;"	f
conold	strainlimiting.cpp	/^    vector<double> conold;$/;"	m	struct:SLOpt	file:
cons	localopt.cpp	/^    vector<Constraint*> cons;    $/;"	m	struct:LocalOpt	file:
cons	popfilter.cpp	/^    const vector<Constraint*> &cons;$/;"	m	struct:PopOpt	file:
cons	strainlimiting.cpp	/^    const vector<Constraint*> &cons;$/;"	m	struct:SLOpt	file:
cons	tensormax.cpp	/^template <typename T> vector<T> cons (const T &x, const vector<T> &v) {$/;"	f
consistency	physics.cpp	/^static void consistency(vector<Vec3>& b, const string& name) {$/;"	f	file:
consistency	simulation.cpp	/^static void consistency(const char* text) {$/;"	f	file:
constraint	collision.cpp	/^double NormalOpt::constraint (const double *x, int j, int &sign) const {$/;"	f	class:NormalOpt
constraint	proxy.cpp	/^Constraint* FloorProxy::constraint(const Node* node) {$/;"	f	class:FloorProxy
constraint	separateobs.cpp	/^double SeparationOpt::constraint (const double *x, int j, int &sign) const {$/;"	f	class:SO::SeparationOpt
constraint	strainlimiting.cpp	/^double SLOpt::constraint (const double *x, int j, int &sign) const {$/;"	f	class:SLOpt
constraint_energy	physics.cpp	/^double constraint_energy (const vector<Constraint*> &cons) {$/;"	f
contains	constraint.cpp	/^bool EqCon::contains(Node* _node) { return node == _node; }$/;"	f	class:EqCon
contains	constraint.cpp	/^bool GlueCon::contains(Node* _node) { return nodes[0] == _node || nodes[1] == _node; }$/;"	f	class:GlueCon
contains	constraint.cpp	/^bool IneqCon::contains(Node *_node) {$/;"	f	class:IneqCon
copy_file	runphysics.cpp	/^void copy_file (const string &input, const string &output) {$/;"	f
count_elements	mesh.hpp	/^template <typename Prim> inline int count_elements (const std::vector<Mesh*>& meshes) {$/;"	f
create_accel_structs	collisionutil.cpp	/^vector<AccelStruct*> create_accel_structs (const vector<Mesh*> &meshes,$/;"	f
create_vert_sizing	dynamicremesh.cpp	/^void create_vert_sizing (vector<Vert*>& verts, const map<Node*,Plane> &planes) {$/;"	f
cross	dynamicremesh.cpp	/^double cross (const Vec2 &u, const Vec2 &v) {return u[0]*v[1] - u[1]*v[0];}$/;"	f
cross	vectors.hpp	/^template <typename T> Vec<3,T> cross (const Vec<3,T> &u, const Vec<3,T> &v) {Vec<3,T> w; w[0] = u[1]*v[2] - u[2]*v[1]; w[1] = u[2]*v[0] - u[0]*v[2]; w[2] = u[0]*v[1] - u[1]*v[0]; return w;}$/;"	f
curr_state_mesh	obstacle.hpp	/^    Mesh curr_state_mesh;$/;"	m	struct:Obstacle
current	display.cpp	/^Pane* Pane::current() { $/;"	f	class:Pane
curvature	geometry.cpp	/^template <Space s> Mat3x3 curvature (const Face *face) {$/;"	f
curvature	mesh.hpp	/^    Mat3x3 curvature; \/\/ filtered curvature for bending fracture$/;"	m	struct:Node
d	dde.hpp	/^struct BendingData {double d[3][5];};$/;"	m	struct:BendingData
d	dde.hpp	/^struct StretchingData {Vec4 d[2][5];};$/;"	m	struct:StretchingData
d	nearobs.cpp	/^    double d;$/;"	m	struct:NearPoint	file:
damage	mesh.hpp	/^    double damage; \/\/ accumulated norm of S_plastic\/S_yield$/;"	m	struct:Face
damage	mesh.hpp	/^    double theta_ideal, damage; \/\/ rest dihedral angle, damage parameter$/;"	m	struct:Edge
damping	cloth.hpp	/^    double damping; \/\/ stiffness-proportional damping coefficient$/;"	m	struct:Material
dde_bending	cloth.hpp	/^    BendingData dde_bending;$/;"	m	struct:Material
dde_stretching	cloth.hpp	/^    StretchingSamples dde_stretching;$/;"	m	struct:Material
deactivate_nodes	mesh.cpp	/^void deactivate_nodes(vector<Node*>& nodes) {$/;"	f
debug	strainlimiting.cpp	/^void debug (const vector<string> &args) {$/;"	f
debug	subset.cpp	/^void MeshSubset::debug() {$/;"	f	class:MeshSubset
debug_color	display.cpp	/^Vec3 debug_color (Face *face, const Vert* vert) {$/;"	f
debug_save_mesh	util.cpp	/^void debug_save_mesh (const Mesh &mesh, const string &name, int n) {$/;"	f
debug_save_meshes	util.cpp	/^void debug_save_meshes (const vector<Mesh*> &meshvec, const string &name,$/;"	f
debug_save_spmat	sparse.hpp	/^inline void debug_save_spmat (const SpMat<double> &A) {$/;"	f
deep_copy	mesh.cpp	/^Mesh deep_copy (Mesh &mesh0) {$/;"	f
deform_obstacles	collision.cpp	/^static bool deform_obstacles;$/;"	v	file:
deform_obstacles	separate.cpp	/^static bool deform_obstacles;$/;"	v	file:
deformation_gradient	physics.cpp	/^Mat3x3 deformation_gradient (const Face *face) {$/;"	f
delete_all	remesh.cpp	/^template <class T> static void delete_all(const vector<T>& a) { for(size_t i=0; i<a.size(); i++) delete a[i]; }$/;"	f	file:
delete_constraints	simulation.cpp	/^void delete_constraints (const vector<Constraint*> &cons) {$/;"	f
delete_mesh	mesh.cpp	/^void delete_mesh (Mesh &mesh) {$/;"	f
delete_spaced_out	dynamicremesh.cpp	/^void delete_spaced_out(Mesh& mesh) {$/;"	f
density	cloth.hpp	/^    double density; \/\/ area density$/;"	m	struct:Material
density	simulation.hpp	/^    double density;$/;"	m	struct:Wind
depth	bvh.hpp	/^	FORCEINLINE float depth()  const { return _dist[11] - _dist[2]; }$/;"	f	class:kDOP18
derivative	mesh.hpp	/^inline Mat3x3 derivative (const Vec3& w0, const Vec3& w1, $/;"	f
derivative	mesh.hpp	/^inline Vec3 derivative (double a0, double a1, double a2, double az, const Face *face) {$/;"	f
destroy_accel_structs	collisionutil.cpp	/^void destroy_accel_structs (vector<AccelStruct*> &accs) {$/;"	f
det	vectors.hpp	/^template <typename T> T det (const Mat<2,2,T> &A) {return A(0,0)*A(1,1) - A(0,1)*A(1,0);}$/;"	f
det	vectors.hpp	/^template <typename T> T det (const Mat<3,3,T> &A) {return stp(A.col(0), A.col(1), A.col(2));}$/;"	f
deterministic_sort	dynamicremesh.cpp	/^} deterministic_sort;$/;"	v	typeref:struct:Deterministic_sort
diag	vectors.hpp	/^template <int n, typename T> MatnnT diag (const VecnT &u) {MatnnT A = MatnnT(0); for (int j = 0; j < n; j++) A(j,j) = u[j]; return A;}$/;"	f
diag	vectors.hpp	/^template <int n, typename T> VecnT diag (const MatnnT &A) {VecnT u; for (int j = 0; j < n; j++) u[j] = A(j,j); return u;}$/;"	f
dihedral_angle	geometry.cpp	/^double dihedral_angle (const Vec3& p0, const Vec3& p1, const Vec3& n0, const Vec3& n1) {$/;"	f
dihedral_angle	geometry.cpp	/^template <Space s> double dihedral_angle (const Edge *edge) {$/;"	f
dilate	bvh.cpp	/^BOX dilate (const BOX &box, double d) {$/;"	f
dir	display.hpp	/^	Vec3 pos, dir;$/;"	m	struct:Annotation
directional_light	display.cpp	/^void directional_light (int i, const Vec3 &dir, const Vec3 &dif) {$/;"	f
directions	handle.cpp	/^static Vec3 directions[3] = {Vec3(1,0,0), Vec3(0,1,0), Vec3(0,0,1)};$/;"	v	file:
displace_sector	breaking.cpp	/^void displace_sector(Node* node, double disp) {$/;"	f
display_material	display.cpp	/^void display_material () {$/;"	f
display_mode	display.cpp	/^int display_mode = 0;$/;"	v
display_modes	display.cpp	/^DisplayMode display_modes[] = { {"sigma", 1e4, true},$/;"	v
display_physics	displayphysics.cpp	/^void display_physics (const vector<string> &args) {$/;"	f
display_plastic	display.cpp	/^void display_plastic () {$/;"	f
display_replay	displayreplay.cpp	/^void display_replay (const vector<string> &args) {$/;"	f
display_resume	displayphysics.cpp	/^void display_resume (const vector<string> &args) {$/;"	f
display_testing	displaytesting.cpp	/^void display_testing (const vector<string> &args) {$/;"	f
display_world	display.cpp	/^void display_world () {$/;"	f
distance	physics.cpp	/^double distance (const Vec3 &x, const Vec3 &a, const Vec3 &b) {$/;"	f
done	remesh.cpp	/^void RemeshOp::done () const {$/;"	f	class:RemeshOp
dot	lsnewton.cpp	/^static double dot (const vector<double> &x, const vector<double> &y) {$/;"	f	file:
dot	trustregion.cpp	/^static double dot (const vector<double> &x, const SpMat<double> &A,$/;"	f	file:
dot	trustregion.cpp	/^static double dot (const vector<double> &x, const vector<double> &y) {$/;"	f	file:
dot	vectors.hpp	/^tpl T dot (const VecnT &u, const VecnT &v) {T d = 0; for (int i = 0; i < n; i++) d += u[i]*v[i]; return d;}$/;"	f
down	display.cpp	/^    bool down;$/;"	m	struct:MouseState	file:
down_x	display.cpp	/^    int down_x, down_y;$/;"	m	struct:MouseState	file:
down_y	display.cpp	/^    int down_x, down_y;$/;"	m	struct:MouseState	file:
drag	simulation.hpp	/^    double drag;$/;"	m	struct:Wind
draw_annotation	display.cpp	/^void draw_annotation(Annotation& a) {$/;"	f
draw_mesh	display.cpp	/^void draw_mesh (const Mesh &mesh, bool set_color=false) {$/;"	f
draw_mesh_ms	display.cpp	/^void draw_mesh_ms (Mesh &mesh, bool set_color=false) {$/;"	f
draw_mesh_ps	display.cpp	/^void draw_mesh_ps (const Mesh &mesh, bool set_color=false) {$/;"	f
draw_meshes	display.cpp	/^void draw_meshes (bool set_color=false) {$/;"	f
draw_meshes_ms	display.cpp	/^void draw_meshes_ms (bool set_color=false) {$/;"	f
draw_meshes_ms_fancy	display.cpp	/^void draw_meshes_ms_fancy () {$/;"	f
draw_meshes_ps	display.cpp	/^void draw_meshes_ps (bool set_color=false) {$/;"	f
draw_node_accels	display.cpp	/^void draw_node_accels () {$/;"	f
draw_node_vels	display.cpp	/^void draw_node_vels () {$/;"	f
draw_seam_or_boundary_edges	display.cpp	/^void draw_seam_or_boundary_edges () {$/;"	f
dsyevc3	vectors.cpp	/^int dsyevc3(const Mat3x3& A, Vec3& w) {$/;"	f
dx0	handle.hpp	/^    Vec3 xc, dx0, dx1;$/;"	m	struct:CircleHandle
dx1	handle.hpp	/^    Vec3 xc, dx0, dx1;$/;"	m	struct:CircleHandle
dynamic_remesh	dynamicremesh.cpp	/^void dynamic_remesh (Mesh& mesh, const map<Node*,Plane> &planes) {$/;"	f
dynamic_remesh	dynamicremesh.cpp	/^void dynamic_remesh (MeshSubset& subset, const map<Node*,Plane> &planes) {$/;"	f
edge	display.hpp	/^	Edge* edge;$/;"	m	struct:Annotation
edge	separate.cpp	/^    Edge *edge[2]; \/\/ edges causing clip$/;"	m	struct:EdgeClipping	file:
edge_box	bvh.cpp	/^BOX edge_box (const Edge *edge, bool ccd) {$/;"	f
edge_face_intersection	separate.cpp	/^bool edge_face_intersection (const Edge* edge, const Face *face, Vec3& pt) {$/;"	f
edge_face_intersection	separate.cpp	/^bool edge_face_intersection (const Vec3& e0, const Vec3& e1,$/;"	f
edge_flip_threshold	magic.hpp	/^    double edge_flip_threshold;$/;"	m	struct:Magic
edge_metric	dynamicremesh.cpp	/^double edge_metric (const Edge *edge) {$/;"	f
edge_metric	dynamicremesh.cpp	/^double edge_metric (const Vert *vert0, const Vert *vert1) {$/;"	f
edge_node_prox	proximity.cpp	/^static vector< Min<Node*> > edge_node_prox;$/;"	v	file:
edge_opp_vert	mesh.hpp	/^inline Vert *edge_opp_vert (const Edge *edge, int side) {$/;"	f
edge_plane_intersect	breaking.cpp	/^double edge_plane_intersect(const Vec3& e0, const Vec3& e1, const Vec3& u0, const Vec3& n) {$/;"	f
edge_prox	proximity.cpp	/^static vector< Min<Edge*> > edge_prox[2];$/;"	v	file:
edge_vert	mesh.hpp	/^inline Vert *edge_vert (const Edge *edge, int side, int i) {$/;"	f
edges	localopt.cpp	/^    const vector<Edge*>& edges;    $/;"	m	struct:LocalOpt	file:
edges	mesh.hpp	/^    std::vector<Edge*> edges;$/;"	m	struct:Mesh
edges_to_face	plasticity.cpp	/^Mat3x3 edges_to_face (const Vec3 &theta, const Face *face) {$/;"	f
ee_clear_distance	separateobs.cpp	/^double ee_clear_distance (const Face *face0, const Face *face1, const Vec3 &d,$/;"	f	namespace:SO
ee_collision_test	collision.cpp	/^bool ee_collision_test (const Edge *edge0, const Edge *edge1, Impact &impact) {$/;"	f
eigen_decomposition	vectors.cpp	/^template <int n> Eig<n> eigen_decomposition (const Mat<n,n> &A) {$/;"	f
eigen_decomposition	vectors.cpp	/^template<> Eig<2> eigen_decomposition<2>(const Mat2x2 &A) {$/;"	f
eigen_decomposition	vectors.cpp	/^template<> Eig<3> eigen_decomposition<3>(const Mat3x3 &B) {$/;"	f
eigen_values	vectors.cpp	/^template <int n> Vec<n> eigen_values (const Mat<n,n> &A) {$/;"	f
eigen_values	vectors.cpp	/^template<> Vec2 eigen_values<2>(const Mat2x2& A) {$/;"	f
eigen_values	vectors.cpp	/^template<> Vec3 eigen_values<3>(const Mat3x3& A) {$/;"	f
embedding_from_plasticity	remesh.cpp	/^void embedding_from_plasticity (const vector<Face*> &fs) {$/;"	f
empty	bvh.hpp	/^	FORCEINLINE void empty() {$/;"	f	class:kDOP18
empty	remesh.hpp	/^    bool empty () {return added_faces.empty() && removed_faces.empty();}$/;"	f	struct:RemeshOp
empty	separate.cpp	/^    bool empty () {return t[0] > t[1];}$/;"	f	struct:EdgeClipping
enable_localopt	magic.hpp	/^    bool enable_localopt;$/;"	m	struct:Magic
enabled	display.hpp	/^    bool enabled;$/;"	m	struct:Pane
enabled	simulation.hpp	/^    bool enabled[nModules];$/;"	m	struct:Simulation
enclosed	tensormax.cpp	/^bool enclosed (const Disk &disk0, const Disk &disk1) {$/;"	f
end_frame	simulation.hpp	/^    double end_time, end_frame;$/;"	m	struct:Simulation
end_time	handle.hpp	/^    double start_time, end_time, fade_time;$/;"	m	struct:Handle
end_time	obstacle.hpp	/^    double start_time, end_time;$/;"	m	struct:Obstacle
end_time	simulation.hpp	/^    double end_time, end_frame;$/;"	m	struct:Simulation
energy	constraint.cpp	/^double EqCon::energy (double value) {return stiff*sq(value)\/2.;}$/;"	f	class:EqCon
energy	constraint.cpp	/^double GlueCon::energy (double value) {return stiff*sq(value)\/2.;}$/;"	f	class:GlueCon
energy	constraint.cpp	/^double IneqCon::energy (double value) {$/;"	f	class:IneqCon
energy_grad	constraint.cpp	/^double EqCon::energy_grad (double value) {return stiff*value;}$/;"	f	class:EqCon
energy_grad	constraint.cpp	/^double GlueCon::energy_grad (double value) {return stiff*value;}$/;"	f	class:GlueCon
energy_grad	constraint.cpp	/^double IneqCon::energy_grad (double value) {$/;"	f	class:IneqCon
energy_hess	constraint.cpp	/^double EqCon::energy_hess (double value) {return stiff;}$/;"	f	class:EqCon
energy_hess	constraint.cpp	/^double GlueCon::energy_hess (double value) {return stiff;}$/;"	f	class:GlueCon
energy_hess	constraint.cpp	/^double IneqCon::energy_hess (double value) {$/;"	f	class:IneqCon
ensure_existing_directory	io.cpp	/^void ensure_existing_directory (const std::string &path) {$/;"	f
entries	sparse.hpp	/^    std::vector<T> entries;$/;"	m	struct:SpVec
eps_f	optimization.hpp	/^    OptOptions &eps_f (double e) {_eps_f = e; return *this;}$/;"	f	struct:OptOptions
eps_f	optimization.hpp	/^    double eps_f () {return _eps_f;}$/;"	f	struct:OptOptions
eps_g	optimization.hpp	/^    OptOptions &eps_g (double e) {_eps_g = e; return *this;}$/;"	f	struct:OptOptions
eps_g	optimization.hpp	/^    double eps_g () {return _eps_g;}$/;"	f	struct:OptOptions
eps_x	optimization.hpp	/^    OptOptions &eps_x (double e) {_eps_x = e; return *this;}$/;"	f	struct:OptOptions
eps_x	optimization.hpp	/^    double eps_x () {return _eps_x;}$/;"	f	struct:OptOptions
equilibration_step	simulation.cpp	/^void equilibration_step (Simulation &sim) {$/;"	f
error	mot_parser.hpp	/^    std::string error;$/;"	m	class:mot_parser_exception
evaluate_stretching_sample	dde.cpp	/^Vec4 evaluate_stretching_sample (const Mat2x2 &_G, const StretchingData &data) {$/;"	f
evaluate_stretching_samples	dde.cpp	/^void evaluate_stretching_samples (StretchingSamples &samples,$/;"	f
exclude	util.hpp	/^template <typename T> inline void exclude (const T &x, std::vector<T> &xs) {$/;"	f
exclude_all	remesh.cpp	/^template <class T> static void exclude_all(const vector<T>& a, vector<T>& b) { for(size_t i=0; i<a.size(); i++) exclude(a[i],b); }$/;"	f	file:
expand_xy	vectors.hpp	/^inline Mat<3,3> expand_xy (const Mat<2,2>& M) { return Mat<3,3> (Vec3(M(0,0),M(0,1),0),Vec3(M(1,0),M(1,1),0),Vec3(0,0,0)); }$/;"	f
expand_xy	vectors.hpp	/^inline Vec<3> expand_xy(const Vec<2>& v) { return Vec<3>(v[0],v[1],0); }$/;"	f
f	constraint.hpp	/^struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };$/;"	m	struct:MeshGradV
f	plasticity.cpp	/^    mutable vector<Vec3> f;$/;"	m	struct:EmbedOpt	file:
f	popfilter.cpp	/^    mutable vector<Vec3> f;$/;"	m	struct:PopOpt	file:
f0	separate.cpp	/^    Face *f0, *f1;$/;"	m	struct:Ixn	file:
f0	separateobs.cpp	/^    Face *f0, *f1;$/;"	m	struct:SO::Ixn	file:
f1	separate.cpp	/^    Face *f0, *f1;$/;"	m	struct:Ixn	file:
f1	separateobs.cpp	/^    Face *f0, *f1;$/;"	m	struct:SO::Ixn	file:
face	display.hpp	/^	Face* face;$/;"	m	struct:Annotation
face	sepstrength.cpp	/^	Face* face;$/;"	m	struct:FanPrecomp	file:
face_box	bvh.cpp	/^BOX face_box (const Face *face, bool ccd) {$/;"	f
face_buffer	bvh.hpp	/^	Face **face_buffer;$/;"	m	class:DeformBVHTree
face_plane_intersection	separate.cpp	/^bool face_plane_intersection (const Face *face, const Face *plane,$/;"	f
face_plane_intersection	separateobs.cpp	/^bool face_plane_intersection (const Face *face, const Face *plane,$/;"	f	namespace:SO
face_prox	proximity.cpp	/^static vector< Min<Node*> > face_prox[2];$/;"	v	file:
face_to_edges	plasticity.cpp	/^Vec3 face_to_edges (const Mat3x3 &S, const Face *face) {$/;"	f
faces	localopt.cpp	/^    const vector<Face*>& faces;$/;"	m	struct:LocalOpt	file:
faces	mesh.hpp	/^    std::vector<Face*> faces;$/;"	m	struct:Mesh
faces	sepstrength.hpp	/^	Face* faces[2];$/;"	m	struct:SplitNode
fade_time	handle.hpp	/^    double start_time, end_time, fade_time;$/;"	m	struct:Handle
farthest_points	separateobs.cpp	/^bool farthest_points (const Face *face0, const Face *face1, const Vec3 &d,$/;"	f	namespace:SO
fill_in_velocity	spline.hpp	/^template <typename T> void fill_in_velocity (Spline<T> &s, int i) {$/;"	f
finalize	collision.cpp	/^void NormalOpt::finalize (const double *x) const {$/;"	f	class:NormalOpt
finalize	localopt.cpp	/^void LocalOpt<s>::finalize (const double *x) const {$/;"	f	class:LocalOpt
finalize	plasticity.cpp	/^void EmbedOpt::finalize (const double *x) const {$/;"	f	class:EmbedOpt
finalize	popfilter.cpp	/^void PopOpt::finalize (const double *x) const {$/;"	f	class:PopOpt
finalize	separateobs.cpp	/^void SeparationOpt::finalize (const double *x) const {$/;"	f	class:SO::SeparationOpt
finalize	strainlimiting.cpp	/^void SLOpt::finalize (const double *x) const {$/;"	f	class:SLOpt
find	bvh.cpp	/^DeformBVHNode::find(Face *face)$/;"	f	class:DeformBVHNode
find	separate.cpp	/^    size_t find (size_t i) {$/;"	f	struct:UnionFind
find	spline.cpp	/^static int find (const Spline<T> &s, double t) {$/;"	f	file:
find	util.hpp	/^template <typename T> inline int find (const T &x, const T *xs, int n=3) {$/;"	f
find	util.hpp	/^template <typename T> inline int find (const T &x, const std::vector<T> &xs) {$/;"	f
find	util.hpp	/^template <typename T> inline int find (const T *x, T* const *xs, int n=3) {$/;"	f
find_bad_edges	dynamicremesh.cpp	/^vector<Edge*> find_bad_edges (const vector<Edge*>& edges) {$/;"	f
find_edges_to_flip	dynamicremesh.cpp	/^vector<Edge*> find_edges_to_flip (vector<Face*>& active_faces){$/;"	f
find_face_impacts	collision.cpp	/^void find_face_impacts (const Face *face0, const Face *face1) {$/;"	f
find_face_intersection	separate.cpp	/^void find_face_intersection (const Face *face0, const Face *face1) {$/;"	f
find_face_intersection	separateobs.cpp	/^void find_face_intersection (const Face *face0, const Face *face1) {$/;"	f	namespace:SO
find_face_overlappings	separate.cpp	/^void find_face_overlappings (const Face *face0, const Face *face1) {$/;"	f
find_impacts	collision.cpp	/^vector<Impact> find_impacts (const vector<AccelStruct*> &accs,$/;"	f
find_index	sparse.hpp	/^inline size_t find_index (int i, const std::vector<int> &indices) {$/;"	f
find_intersections	separate.cpp	/^vector<Ixn> find_intersections (const vector<AccelStruct*> &accs,$/;"	f
find_intersections	separateobs.cpp	/^vector<Ixn> find_intersections (const vector<AccelStruct*> &accs,$/;"	f	namespace:SO
find_or_create_zone	collision.cpp	/^ImpactZone *find_or_create_zone (const Node *node, vector<ImpactZone*> &zones) {$/;"	f
find_overlappings	separate.cpp	/^vector<Ixn> find_overlappings (const vector<AccelStruct*> &accs,$/;"	f
find_proximities	proximity.cpp	/^void find_proximities (const Face *face0, const Face *face1) {$/;"	f
finite	winport.hpp	/^template <class T> inline bool   finite(const T& number) { return boost::math::isfinite(number); }$/;"	f
fix_nonmanifold	breaking.cpp	/^void fix_nonmanifold(Node* node, MeshSubset& subset) {$/;"	f
fixed_high_res_mesh	magic.hpp	/^    bool fixed_high_res_mesh;$/;"	m	struct:Magic
flag	mesh.hpp	/^    int flag;$/;"	m	struct:Face
flag	mesh.hpp	/^    int flag;$/;"	m	struct:Node
flip_edge	remesh.cpp	/^RemeshOp flip_edge (Edge* edge) {$/;"	f
flip_edges	dynamicremesh.cpp	/^void flip_edges (MeshSubset* subset, vector<Face*>& active_faces, $/;"	f
flip_image	io.cpp	/^void flip_image (int w, int h, unsigned char *pixels) {$/;"	f
flip_some_edges	dynamicremesh.cpp	/^bool flip_some_edges (MeshSubset* subset, vector<Face*>& active_faces, $/;"	f
for_faces_overlapping_obstacles	collisionutil.cpp	/^void for_faces_overlapping_obstacles (const vector<AccelStruct*> &accs,$/;"	f
for_overlapping_faces	collisionutil.cpp	/^void for_overlapping_faces (BVHNode *node, float thickness,$/;"	f
for_overlapping_faces	collisionutil.cpp	/^void for_overlapping_faces (BVHNode *node0, BVHNode *node1, float thickness,$/;"	f
for_overlapping_faces	collisionutil.cpp	/^void for_overlapping_faces (const vector<AccelStruct*> &accs,$/;"	f
fp	util.hpp	/^	gzFile fp;$/;"	m	struct:Serialize
fps	runphysics.cpp	/^Timer fps;$/;"	v
fracture	simulation.cpp	/^                 fracture = Simulation::Fracture;$/;"	v	file:
fracture_bend_thickness	cloth.hpp	/^    double toughness, fracture_bend_thickness; \/\/ fracture toughness$/;"	m	struct:Material
fracture_metric	dynamicremesh.cpp	/^Mat2x2 fracture_metric (Remeshing& remeshing, const Face* face) {$/;"	f
frame	runphysics.cpp	/^int frame;$/;"	v
frame	simulation.hpp	/^    int frame, step;$/;"	m	struct:Simulation
frame_steps	simulation.hpp	/^    int frame_steps, save_every;$/;"	m	struct:Simulation
frame_time	simulation.hpp	/^    double frame_time, step_time;$/;"	m	struct:Simulation
frame_x	sepstrength.cpp	/^	Vec3 frame_x, frame_y;$/;"	m	struct:FanPrecomp	file:
frame_y	sepstrength.cpp	/^	Vec3 frame_x, frame_y;$/;"	m	struct:FanPrecomp	file:
frameskip	displayreplay.cpp	/^static int frameskip;$/;"	v	file:
free	constraint.hpp	/^    bool free[4];$/;"	m	struct:IneqCon
friction	constraint.cpp	/^MeshGrad EqCon::friction (double dt, MeshHess &jac) {return MeshGrad();}$/;"	f	class:EqCon
friction	constraint.cpp	/^MeshGrad GlueCon::friction (double dt, MeshHess &jac) {return MeshGrad();}$/;"	f	class:GlueCon
friction	constraint.cpp	/^MeshGrad IneqCon::friction (double dt, MeshHess &jac) {$/;"	f	class:IneqCon
friction	simulation.hpp	/^    double friction, obs_friction;$/;"	m	struct:Simulation
from_axisangle	transformation.cpp	/^Quaternion Quaternion::from_axisangle(const Vec3 &axis, double angle) {$/;"	f	class:Quaternion
func	display.cpp	/^    enum {ROTATE, TRANSLATE, SCALE} func;$/;"	m	struct:MouseState	typeref:enum:MouseState::__anon1	file:
g0	separate.cpp	/^    Vec3 g0[3], g1[3]; \/\/ dl\/dx for each of the faces' nodes$/;"	m	struct:Ixn	file:
g1	separate.cpp	/^    Vec3 g0[3], g1[3]; \/\/ dl\/dx for each of the faces' nodes$/;"	m	struct:Ixn	file:
generate_obj	displayreplay.cpp	/^void generate_obj (const vector<string> &args) {$/;"	f
get	mesh.hpp	/^template <> inline const std::vector<Edge*> &get (const Mesh &mesh) {return mesh.edges;}$/;"	f
get	mesh.hpp	/^template <> inline const std::vector<Face*> &get (const Mesh &mesh) {return mesh.faces;}$/;"	f
get	mesh.hpp	/^template <> inline const std::vector<Node*> &get (const Mesh &mesh) {return mesh.nodes;}$/;"	f
get	mesh.hpp	/^template <> inline const std::vector<Vert*> &get (const Mesh &mesh) {return mesh.verts;}$/;"	f
get	strainlimiting.cpp	/^T* get(int n, const vector<Mesh*>& meshes) {$/;"	f
getDistances	bvh.hpp	/^	FORCEINLINE static float getDistances(const vec3f &p, int i)$/;"	f	class:kDOP18
getDistances	bvh.hpp	/^	FORCEINLINE static void getDistances(const vec3f& p, float d[])$/;"	f	class:kDOP18
getDistances	bvh.hpp	/^	FORCEINLINE static void getDistances(const vec3f& p,$/;"	f	class:kDOP18
getFace	bvh.hpp	/^	FORCEINLINE Face *getFace() { return _face; }$/;"	f	class:DeformBVHNode
getLeftChild	bvh.hpp	/^	FORCEINLINE DeformBVHNode *getLeftChild() { return _left; }$/;"	f	class:DeformBVHNode
getParent	bvh.hpp	/^	FORCEINLINE DeformBVHNode *getParent() { return _parent; }$/;"	f	class:DeformBVHNode
getRightChild	bvh.hpp	/^	FORCEINLINE DeformBVHNode *getRightChild() { return _right; }$/;"	f	class:DeformBVHNode
getRoot	bvh.hpp	/^	FORCEINLINE DeformBVHNode *getRoot() { return _root; }$/;"	f	class:DeformBVHTree
get_all_nodes	subset.cpp	/^vector<Node*> MeshSubset::get_all_nodes() {$/;"	f	class:MeshSubset
get_angle	geometry.cpp	/^double get_angle(const Vec3& u, const Vec3& v) {$/;"	f
get_barycentric_coords	geometry.cpp	/^Vec3 get_barycentric_coords(const Vec2& point, const Face* f) {$/;"	f
get_body_frame	mot_parser.cpp	/^BodyFrame& get_body_frame(BodyVector &bodies, size_t body_index, size_t frame) {$/;"	f
get_body_frames	mot_parser.cpp	/^BodyFrameVector& get_body_frames(BodyVector &bodies, size_t body_index) {$/;"	f
get_constraints	handle.cpp	/^vector<Constraint*> CircleHandle::get_constraints (double t) {$/;"	f	class:CircleHandle
get_constraints	handle.cpp	/^vector<Constraint*> GlueHandle::get_constraints (double t) {$/;"	f	class:GlueHandle
get_constraints	handle.cpp	/^vector<Constraint*> NodeHandle::get_constraints (double t) {$/;"	f	class:NodeHandle
get_constraints	handle.cpp	/^vector<Constraint*> SoftHandle::get_constraints (double t) {$/;"	f	class:SoftHandle
get_constraints	simulation.cpp	/^vector<Constraint*> get_constraints (Simulation &sim, bool include_proximity) {$/;"	f
get_dtrans	transformation.cpp	/^DTransformation get_dtrans (const Motion &motion, double t) {$/;"	f
get_edge	mesh.hpp	/^inline Edge *get_edge (const Node *n0, const Node *n1) {$/;"	f
get_edges	subset.cpp	/^vector<Edge*> MeshSubset::get_edges() {$/;"	f	class:MeshSubset
get_enclosing_face	geometry.cpp	/^Face* get_enclosing_face(const Mesh& mesh, const Vec2& u,$/;"	f
get_faces	subset.cpp	/^vector<Face*> MeshSubset::get_faces() {$/;"	f	class:MeshSubset
get_line_of_intersection	separate.cpp	/^bool get_line_of_intersection (const Face *face0, const Face *face1, Line3& line) {$/;"	f
get_mass	collision.cpp	/^static double get_mass (const Node *node) {$/;"	f	file:
get_mass	separate.cpp	/^static double get_mass (const Node *node) {$/;"	f	file:
get_mesh	obstacle.cpp	/^Mesh& Obstacle::get_mesh() {$/;"	f	class:Obstacle
get_mesh	obstacle.cpp	/^Mesh& Obstacle::get_mesh(double time) {$/;"	f	class:Obstacle
get_mesh	obstacle.cpp	/^const Mesh& Obstacle::get_mesh() const {$/;"	f	class:Obstacle
get_ms_span	sepstrength.cpp	/^static Vec3 get_ms_span (Face* f, Node* center, int offset) {$/;"	f	file:
get_nodes	handle.cpp	/^vector<Node*> SoftHandle::get_nodes() {$/;"	f	class:SoftHandle
get_nodes	handle.hpp	/^    std::vector<Node*> get_nodes () {$/;"	f	struct:GlueHandle
get_nodes	handle.hpp	/^    std::vector<Node*> get_nodes () {return std::vector<Node*>();}$/;"	f	struct:CircleHandle
get_nodes	handle.hpp	/^    std::vector<Node*> get_nodes () {return std::vector<Node*>(1, node);}$/;"	f	struct:NodeHandle
get_outwards_normal	proximity.cpp	/^static inline Vec3 get_outwards_normal(const Edge *e) {$/;"	f	file:
get_positive	vectors.cpp	/^template <int n> Mat<n,n> get_positive (const Mat<n,n> &A) {$/;"	f
get_strain_limits	strainlimiting.cpp	/^vector<StrainLimit> get_strain_limits (const vector<Cloth> &cloths) {$/;"	f
get_submat	optimization.hpp	/^inline Mat3x3 get_submat (SpMat<double> &A, int i, int j) {$/;"	f
get_subvec	optimization.hpp	/^inline Vec3 get_subvec (const double *x, int i) {$/;"	f
get_subvec	optimization.hpp	/^template <int n> Vec<n> get_subvec (const double *x, int i) {$/;"	f
get_trans	transformation.cpp	/^Transformation get_trans (const Motion &motion, double t) {$/;"	f
get_valid_line	io.cpp	/^void get_valid_line (istream &in, string &line) {$/;"	f
get_vert	mesh.hpp	/^inline Vert* get_vert (const Face* face, const Node* node) {$/;"	f
get_verts	subset.cpp	/^vector<Vert*> MeshSubset::get_verts() {$/;"	f	class:MeshSubset
gradient	constraint.cpp	/^MeshGrad EqCon::gradient () {MeshGrad grad; grad.push_back(MeshGradV(node,n)); return grad;}$/;"	f	class:EqCon
gradient	constraint.cpp	/^MeshGrad GlueCon::gradient () {$/;"	f	class:GlueCon
gradient	constraint.cpp	/^MeshGrad IneqCon::gradient () {$/;"	f	class:IneqCon
gradient	localopt.cpp	/^void LocalOpt<s>::gradient (const double *x, double *g) const {$/;"	f	class:LocalOpt
gradient	plasticity.cpp	/^void EmbedOpt::gradient (const double *x, double *g) const {$/;"	f	class:EmbedOpt
gradient	popfilter.cpp	/^void PopOpt::gradient (const double *x, double *g) const {$/;"	f	class:PopOpt
gravity	simulation.hpp	/^    Vec3 gravity;$/;"	m	struct:Simulation
grow	subset.cpp	/^void MeshSubset::grow(int rings) {$/;"	f	class:MeshSubset
handle_stiffness	magic.hpp	/^    double handle_stiffness, collision_stiffness;$/;"	m	struct:Magic
handles	simulation.hpp	/^    std::vector<Handle*> handles;$/;"	m	struct:Simulation
has_labeled_edges	dynamicremesh.cpp	/^bool has_labeled_edges (const Node *node) {$/;"	f
has_node	proximity.cpp	/^static inline bool has_node(const Face* f, const Node* n) {$/;"	f	file:
head	tensormax.cpp	/^template <typename T> T head (const vector<T> &v) {$/;"	f
height	bvh.hpp	/^	FORCEINLINE float height() const { return _dist[10] - _dist[1]; }$/;"	f	class:kDOP18
hessian	localopt.cpp	/^bool LocalOpt<s>::hessian (const double *x, SpMat<double> &H) const {$/;"	f	class:LocalOpt
hessian	optimization.hpp	/^    virtual bool hessian (const double *x, SpMat<double> &H) const {$/;"	f	struct:NLOpt
hessian	plasticity.cpp	/^bool EmbedOpt::hessian (const double *x, SpMat<double> &H) const {$/;"	f	class:EmbedOpt
hessian	popfilter.cpp	/^bool PopOpt::hessian (const double *x, SpMat<double> &H) const {$/;"	f	class:PopOpt
i	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};$/;"	m	struct:MeshHessV
identity	transformation.cpp	/^Transformation identity () {$/;"	f
idle	display.hpp	/^    void (*idle) ();$/;"	m	struct:GlutCallbacks
idle	displayphysics.cpp	/^static void idle () {$/;"	f	file:
idle	displayreplay.cpp	/^static void idle () {$/;"	f	file:
impacts	collision.cpp	/^    vector<Impact> impacts;$/;"	m	struct:ImpactZone	file:
impacts	collision.cpp	/^static vector<Impact> *impacts = NULL;$/;"	v	file:
implicit_update	physics.cpp	/^vector<Vec3> implicit_update (vector<Node*>& nodes, const vector<Edge*>& edges, const vector<Face*>& faces,$/;"	f
improve_some_face	dynamicremesh.cpp	/^bool improve_some_face (MeshSubset* subset, vector<Face*>& active) {$/;"	f
in_wedge	proximity.cpp	/^bool in_wedge (double w, const Edge *edge0, const Edge *edge1) {$/;"	f
include	util.hpp	/^template <typename T> inline void include (const T &x, std::vector<T> &xs) {$/;"	f
include_all	remesh.cpp	/^template <class T> static void include_all(const vector<T>& a, vector<T>& b) { for(size_t i=0; i<a.size(); i++) include(a[i],b); }$/;"	f	file:
independent	dynamicremesh.cpp	/^bool independent (const Edge *edge, const vector<Edge*> &edges) {$/;"	f
independent_edges	dynamicremesh.cpp	/^vector<Edge*> independent_edges (const vector<Edge*> &edges) {$/;"	f
independent_impacts	collision.cpp	/^vector<Impact> independent_impacts (const vector<Impact> &impacts) {$/;"	f
index	mesh.hpp	/^    int index; \/\/ position in mesh.edges$/;"	m	struct:Edge
index	mesh.hpp	/^    int index; \/\/ position in mesh.faces$/;"	m	struct:Face
index	mesh.hpp	/^    int index; \/\/ position in mesh.nodes$/;"	m	struct:Node
index	mesh.hpp	/^    int index; \/\/ position in mesh.verts$/;"	m	struct:Vert
indices	physics.cpp	/^Vec<3,int> indices (const Node *n0, const Node *n1, const Node *n2) {$/;"	f
indices	physics.cpp	/^Vec<4,int> indices (const Node *n0, const Node *n1,$/;"	f
indices	sparse.hpp	/^    std::vector<int> indices;$/;"	m	struct:SpVec
infinity	util.cpp	/^const double infinity = numeric_limits<double>::infinity();$/;"	v
init_glut	display.cpp	/^void init_glut (const GlutCallbacks &cb) {$/;"	f
init_physics	runphysics.cpp	/^void init_physics (const string &json_file, string outprefix,$/;"	f
init_relax	runphysics.cpp	/^void init_relax() {$/;"	f
init_resume	runphysics.cpp	/^void init_resume(const vector<string> &args) {$/;"	f
init_view	display.cpp	/^void init_view(Pane& view) {$/;"	f
initialize	collision.cpp	/^void NormalOpt::initialize (double *x) const {$/;"	f	class:NormalOpt
initialize	localopt.cpp	/^void LocalOpt<s>::initialize (double *x) const {$/;"	f	class:LocalOpt
initialize	plasticity.cpp	/^void EmbedOpt::initialize (double *x) const {$/;"	f	class:EmbedOpt
initialize	popfilter.cpp	/^void PopOpt::initialize (double *x) const {$/;"	f	class:PopOpt
initialize	separateobs.cpp	/^void SeparationOpt::initialize (double *x) const {$/;"	f	class:SO::SeparationOpt
initialize	strainlimiting.cpp	/^void SLOpt::initialize (double *x) const {$/;"	f	class:SLOpt
initialized	display.hpp	/^    bool initialized;$/;"	m	struct:Pane
inner	vectors.hpp	/^tpl T inner (const MatmnT &a, const MatmnT& b) { T r=0; for (int j=0; j<n; j++) for (int i=0; i<m; i++) r+=a.col(j)[i]*b.col(j)[i]; return r;}$/;"	f
insert_index	sparse.hpp	/^template <typename T> void insert_index (int i, int j,$/;"	f
inside	bvh.cpp	/^	FORCEINLINE bool inside(const vec3f &mid) const {$/;"	f	class:aap
inside	bvh.hpp	/^	FORCEINLINE bool inside(const vec3f &p) const$/;"	f	class:kDOP18
internal_energy	physics.cpp	/^double internal_energy (const vector<Face*>& faces, const vector<Edge*>& edges) {$/;"	f
intersection_midpoint	separate.cpp	/^bool intersection_midpoint (const Face *face0, const Face *face1,$/;"	f
intersection_midpoint	separateobs.cpp	/^bool intersection_midpoint (const Face *face0, const Face *face1,$/;"	f	namespace:SO
inv	vectors.hpp	/^    MatmnT inv () const {return inverse(*this);}$/;"	f	class:Mat
invDm	mesh.hpp	/^    Mat3x3 Dm, invDm; \/\/ finite element matrix$/;"	m	struct:Face
inv_m	collision.cpp	/^    double inv_m;$/;"	m	struct:NormalOpt	file:
inv_m	separateobs.cpp	/^    double inv_m;$/;"	m	struct:SO::SeparationOpt	file:
inv_m	strainlimiting.cpp	/^    double inv_m;$/;"	m	struct:SLOpt	file:
inverse	remesh.cpp	/^RemeshOp RemeshOp::inverse () const {$/;"	f	class:RemeshOp
inverse	transformation.cpp	/^Quaternion inverse(const Quaternion &q) {$/;"	f
inverse	transformation.cpp	/^Transformation inverse(const Transformation &tr) {$/;"	f
inverse	vectors.hpp	/^template <typename T> Mat<2,2,T> inverse (const Mat<2,2,T> &A) {return Mat<2,2,T>(Vec<2,T>(A(1,1), -A(1,0)), Vec<2,T>(-A(0,1), A(0,0)))\/det(A);}$/;"	f
inverse	vectors.hpp	/^template <typename T> Mat<3,3,T> inverse (const Mat<3,3,T> &A) {return Mat<3,3,T>(cross(A.col(1),A.col(2)), cross(A.col(2),A.col(0)), cross(A.col(0),A.col(1))).t()\/det(A);}$/;"	f
isLeaf	bvh.hpp	/^	FORCEINLINE bool isLeaf() { return _left == NULL; }$/;"	f	class:DeformBVHNode
isRoot	bvh.hpp	/^	FORCEINLINE bool isRoot() { return _parent == NULL;}$/;"	f	class:DeformBVHNode
is_all_whitespace	mot_parser.cpp	/^bool is_all_whitespace(const string& empty) {$/;"	f
is_bullshit	vectors.hpp	/^tpl inline bool is_bullshit(const VecnT& v) { for (int i=0; i<n; i++) { if (v[i] > 1e100 || v[i] < -1e100 || v[i] != v[i]) return true; } return false; }$/;"	f
is_finite	util.hpp	/^inline bool is_finite(double x) { return x > -1e300 && x < 1e300; }$/;"	f
is_free	collisionutil.hpp	/^template<> inline bool is_free<Edge> (const Edge* p) { return p->n[0]->verts[0]->adjf[0]->material; }$/;"	f
is_free	collisionutil.hpp	/^template<> inline bool is_free<Face> (const Face* p) { return p->material; }$/;"	f
is_free	collisionutil.hpp	/^template<> inline bool is_free<Node> (const Node* p) { return p->verts[0]->adjf[0]->material; }$/;"	f
is_free	collisionutil.hpp	/^template<> inline bool is_free<Vert> (const Vert* p) { return p->adjf[0]->material; }$/;"	f
is_in	util.hpp	/^template <typename T> inline bool is_in (const T &x, const T *xs, int n=3) {$/;"	f
is_in	util.hpp	/^template <typename T> inline bool is_in (const T &x, const std::vector<T> &xs) {$/;"	f
is_in	util.hpp	/^template <typename T> inline bool is_in (const T *x, T* const *xs, int n=3) {$/;"	f
is_inside	geometry.cpp	/^bool is_inside(const Vec2& point, const Face* f) {$/;"	f
is_seam	util.cpp	/^bool is_seam (const Edge* e) {$/;"	f
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary (const Edge *e) {$/;"	f
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary (const Face *f) {$/;"	f
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary (const Node *n) {$/;"	f
is_seam_or_boundary	util.cpp	/^bool is_seam_or_boundary (const Vert *v) {$/;"	f
isfinite	winport.hpp	/^template <class T> inline bool isfinite(const T& number) { return boost::math::isfinite(number); }$/;"	f
ixns	separate.cpp	/^static vector<Ixn> *ixns = NULL;$/;"	v	file:
ixns	separateobs.cpp	/^    const vector<Ixn> &ixns;$/;"	m	struct:SO::SeparationOpt	file:
ixns	separateobs.cpp	/^static vector<Ixn> *ixns = NULL;$/;"	m	namespace:SO	file:
j	constraint.hpp	/^struct MeshHessV { Node* i; Node* j; Mat3x3 J; MeshHessV(Node *i, Node* j, const Mat3x3& J) : i(i), j(j), J(J) {}};$/;"	m	struct:MeshHessV
kDOP18	bvh.hpp	/^	FORCEINLINE kDOP18() {$/;"	f	class:kDOP18
kDOP18	bvh.hpp	/^	FORCEINLINE kDOP18(const vec3f &a, const vec3f &b) {$/;"	f	class:kDOP18
kDOP18	bvh.hpp	/^	FORCEINLINE kDOP18(const vec3f &v) {$/;"	f	class:kDOP18
kDOP18	bvh.hpp	/^class kDOP18 {$/;"	c
key	nearobs.cpp	/^    double key;$/;"	m	struct:Min	file:
key	proximity.cpp	/^    double key;$/;"	m	struct:Min	file:
keyboard	display.hpp	/^    void (*keyboard) (unsigned char, int, int);$/;"	m	struct:GlutCallbacks
keyboard	displayphysics.cpp	/^static void keyboard (unsigned char key, int x, int y) {$/;"	f	file:
keyboard	displayreplay.cpp	/^static void keyboard (unsigned char key, int x, int y) {$/;"	f	file:
keyboard	displaytesting.cpp	/^static void keyboard (unsigned char key, int x, int y) {$/;"	f	file:
keyboard_handler	display.cpp	/^void keyboard_handler(unsigned char key, int x, int y) {$/;"	f
keyboard_sub	display.cpp	/^void (*keyboard_sub)(unsigned char, int, int);$/;"	v
kronecker	physics.cpp	/^Mat<m*p,n*q> kronecker (const Mat<m,n> &A, const Mat<p,q> &B) {$/;"	f
l	separate.cpp	/^    double l;$/;"	m	struct:Ixn	file:
l	vectors.hpp	/^    Vec<n> l;$/;"	m	struct:Eig
l_bfgs_method	lbfgs.cpp	/^void l_bfgs_method (const NLOpt &problem, OptOptions opt, bool verbose) {$/;"	f
label	handle.hpp	/^    int label;$/;"	m	struct:CircleHandle
label	mesh.hpp	/^    int label;$/;"	m	struct:Node
lambda	auglag.cpp	/^static vector<double> lambda;$/;"	v	file:
lapack_int	vectors.cpp	42;"	d	file:
last	timer.hpp	/^    double last, total;$/;"	m	struct:Timer
lat	display.hpp	/^	double lat, lon;$/;"	m	struct:Pane
lbfgs_value_and_grad	lbfgs.cpp	/^static void lbfgs_value_and_grad (const real_1d_array &x, double &value,$/;"	f	file:
leaves	collisionutil.hpp	/^    std::map<const Face*, BVHNode*> leaves;$/;"	m	struct:AccelStruct
length	bvh.hpp	/^	FORCEINLINE float length(int i) const {$/;"	f	class:kDOP18
line_circle_intersection	trustregion.cpp	/^double line_circle_intersection (double n1, double n2, double d, double r) {$/;"	f
line_search	lsnewton.cpp	/^double line_search (const vector<double> &x0, const vector<double> &p,$/;"	f
line_search_newtons_method	lsnewton.cpp	/^void line_search_newtons_method (const NLOpt &problem, OptOptions opt,$/;"	f
list	display.cpp	/^vector<Annotation> Annotation::list;$/;"	m	class:Annotation	file:
list	display.hpp	/^	static std::vector<Annotation> list;$/;"	m	struct:Annotation
load	util.hpp	/^	bool load() { return mode == Load; }$/;"	f	struct:Serialize
load_json	conf.cpp	/^void load_json (const string &configFilename, Simulation &sim) {$/;"	f
load_material_data	conf.cpp	/^void load_material_data (Material &material, const string &filename) {$/;"	f
load_mot	mot_parser.cpp	/^std::vector<Motion> load_mot (const std::string &filename, double fps) {$/;"	f
load_obj	io.cpp	/^void load_obj (Mesh &mesh, const string &filename) {$/;"	f
load_objs	io.cpp	/^void load_objs (vector<Mesh*> &meshes, const string &prefix) {$/;"	f
load_state	io.cpp	/^bool load_state (T& state, const string &prefix) {$/;"	f
local_base	geometry.cpp	/^Mat3x3 local_base(const Vec3& normal) {$/;"	f
local_opt	localopt.cpp	/^void local_opt(vector<Node*>& nodes, vector<Face*>& faces, vector<Edge*>& edges,$/;"	f
local_physics_step	breaking.cpp	/^void local_physics_step(MeshSubset& subset) {$/;"	f
local_pop_filter	remesh.cpp	/^void local_pop_filter (const vector<Face*> &fs) {$/;"	f
log2	winport.hpp	/^template <class T> inline T log2(const T& number) { return log(number)\/log(T(2)); }$/;"	f
log_stiffness	morph.hpp	/^    Spline<double> log_stiffness;$/;"	m	struct:Morph
lon	display.hpp	/^	double lat, lon;$/;"	m	struct:Pane
m	mesh.hpp	/^    double a, m; \/\/ area, mass$/;"	m	struct:Face
m	mesh.hpp	/^    double a, m; \/\/ area, mass$/;"	m	struct:Node
m	sparse.hpp	/^    int m, n;$/;"	m	struct:SpMat
magic	magic.cpp	/^Magic magic;$/;"	v
main	main.cpp	/^int main (int argc, char **argv) {$/;"	f
major_axis	separate.cpp	/^int major_axis (const Vec3 &v) {$/;"	f
major_axis	separateobs.cpp	/^int major_axis (const Vec3 &v) {$/;"	f	namespace:SO
make_constraint	proximity.cpp	/^Constraint *make_constraint (const Edge *edge0, const Edge *edge1,$/;"	f
make_constraint	proximity.cpp	/^Constraint *make_constraint (const Edge* edge, const Node* node, double mu, double mu_obs) {$/;"	f
make_constraint	proximity.cpp	/^Constraint *make_constraint (const Node *node, const Face *face,$/;"	f
make_proxy_constraints	proximity.cpp	/^void make_proxy_constraints (Mesh& mesh, CollisionProxy& proxy, vector<Constraint*>& cons) {$/;"	f
malloc_align	vectors.hpp	/^inline void* malloc_align(size_t size, size_t alignment = 32) { return _aligned_malloc(size, alignment); }$/;"	f
malloc_align	vectors.hpp	/^inline void* malloc_align(size_t size, size_t alignment = 32) {$/;"	f
mark_active	collisionutil.cpp	/^void mark_active (AccelStruct &acc, const Face *face) {$/;"	f
mark_all_inactive	collisionutil.cpp	/^void mark_all_inactive (AccelStruct &acc) {$/;"	f
mark_ancestors	collisionutil.cpp	/^void mark_ancestors (BVHNode *node, bool active) {$/;"	f
mark_descendants	collisionutil.cpp	/^void mark_descendants (BVHNode *node, bool active) {$/;"	f
mark_nodes_to_preserve	mesh.cpp	/^void mark_nodes_to_preserve (Mesh &mesh) {$/;"	f
mat_to_vec	blockvectors.hpp	/^Vec<m*n,T> mat_to_vec (const Mat<m,n,T> &A) {$/;"	f
material	display.hpp	/^    static Pane& material() { return panes[0]; }$/;"	f	struct:Pane
material	mesh.hpp	/^    Material* material;$/;"	m	struct:Face
material_model	physics.cpp	/^Mat3x3 material_model (const Face *face, const Mat3x3& G) {$/;"	f
materials	cloth.hpp	/^    std::vector<Material*> materials;    $/;"	m	struct:Cloth
matrix_mag	display.cpp	/^inline double matrix_mag(const Mat3x3& M) {$/;"	f
max	conf.cpp	/^    double &min, &max;$/;"	m	struct:Range	file:
max	strainlimiting.hpp	/^    double min, max;$/;"	m	struct:StrainLimit
max	util.cpp	/^double Stats::max () const {sort(); return xs.back();}$/;"	f	class:Stats
max	util.hpp	/^template <typename T> T max (const T &a, const T &b, const T &c) {$/;"	f
max	util.hpp	/^template <typename T> T max (const T &a, const T &b, const T &c, const T &d) {$/;"	f
max	vectors.hpp	/^tpl MatmnT max (const MatmnT& a, const MatmnT& b) { MatmnT c; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) c(i,j) = std::max(a(i,j), b(i,j)); return c; }$/;"	f
max	winport.hpp	45;"	d
max_cracks	magic.hpp	/^    int relax_method, max_cracks;$/;"	m	struct:Magic
max_iter	collision.cpp	/^static const int max_iter = 30;$/;"	v	file:
max_iter	optimization.hpp	/^    OptOptions &max_iter (int n) {_max_iter = n; return *this;}$/;"	f	struct:OptOptions
max_iter	optimization.hpp	/^    int max_iter () {return _max_iter;}$/;"	f	struct:OptOptions
max_iter	separateobs.cpp	/^static const int max_iter = 100;$/;"	m	namespace:SO	file:
mean	util.cpp	/^double Stats::mean () const {return sum\/xs.size();}$/;"	f	class:Stats
median	util.cpp	/^double Stats::median () const {return quantile(0.5);}$/;"	f	class:Stats
merge_meshes	misc.cpp	/^void merge_meshes (const vector<string> &args) {$/;"	f
merge_zones	collision.cpp	/^void merge_zones (ImpactZone* zone0, ImpactZone *zone1,$/;"	f
mesh	cloth.hpp	/^    Mesh mesh;$/;"	m	struct:Cloth
mesh	handle.hpp	/^    Mesh *mesh;$/;"	m	struct:CircleHandle
mesh	handle.hpp	/^    Mesh *mesh;$/;"	m	struct:SoftHandle
mesh	mesh.hpp	/^	Mesh* mesh;$/;"	m	struct:Node
mesh	morph.hpp	/^    Mesh *mesh;$/;"	m	struct:Morph
mesh	plasticity.cpp	/^    Mesh &mesh;$/;"	m	struct:EmbedOpt	file:
mesh	popfilter.cpp	/^    Mesh &mesh;$/;"	m	struct:PopOpt	file:
meshes	collisionutil.cpp	/^const vector<Mesh*> *meshes, *obs_meshes;$/;"	v
meshes	strainlimiting.cpp	/^    vector<Mesh*> meshes;$/;"	m	struct:SLOpt	file:
middle_xyz	bvh.cpp	/^inline float middle_xyz(char xyz, const vec3f &p1, const vec3f &p2, const vec3f &p3)$/;"	f
min	conf.cpp	/^    double &min, &max;$/;"	m	struct:Range	file:
min	strainlimiting.hpp	/^    double min, max;$/;"	m	struct:StrainLimit
min	util.cpp	/^double Stats::min () const {sort(); return xs.front();}$/;"	f	class:Stats
min	util.hpp	/^template <typename T> T min (const T &a, const T &b, const T &c) {$/;"	f
min	util.hpp	/^template <typename T> T min (const T &a, const T &b, const T &c, const T &d) {$/;"	f
min	winport.hpp	44;"	d
minidisk	tensormax.cpp	/^Disk minidisk (const vector<Disk> &P) {$/;"	f
minimize_in_ball	trustregion.cpp	/^bool minimize_in_ball (const vector<double> &g, const SpMat<double> &H,$/;"	f
mode	util.hpp	/^	Mode mode;$/;"	m	struct:Serialize
morphs	simulation.hpp	/^    std::vector<Morph> morphs;$/;"	m	struct:Simulation
mot_parser_exception	mot_parser.hpp	/^    mot_parser_exception(const std::string& error) : error(error) {}$/;"	f	class:mot_parser_exception
mot_parser_exception	mot_parser.hpp	/^class mot_parser_exception {$/;"	c
mot_to_spline	mot_parser.cpp	/^vector<Spline<Transformation> > mot_to_spline(string motion_file, const Transformation& tr,$/;"	f
mot_to_transforms	mot_parser.cpp	/^vector<vector<Transformation> > mot_to_transforms(string motion_file) {$/;"	f
motion	display.cpp	/^void motion (int x, int y) {$/;"	f
motion	handle.hpp	/^    const Motion *motion;$/;"	m	struct:CircleHandle
motion	handle.hpp	/^    const Motion *motion;$/;"	m	struct:NodeHandle
motion	handle.hpp	/^    const Motion *motion;$/;"	m	struct:SoftHandle
motions	simulation.hpp	/^    std::vector<Motion> motions;$/;"	m	struct:Simulation
mouse	display.cpp	/^void mouse (int button, int state, int x, int y) {$/;"	f
mouse_state	display.cpp	/^} mouse_state;$/;"	v	typeref:struct:MouseState
mu	auglag.cpp	/^static double mu;$/;"	v	file:
mu	constraint.hpp	/^    double mu; \/\/ friction$/;"	m	struct:IneqCon
mu	plasticity.cpp	/^static const double mu = 1e-6;$/;"	v	file:
mu	popfilter.cpp	/^static double mu;$/;"	v	file:
multiplier_update	auglag.cpp	/^static void multiplier_update (const real_1d_array &x) {$/;"	f	file:
n	collision.cpp	/^    Vec3 n;$/;"	m	struct:Impact	file:
n	constraint.hpp	/^    Vec3 n;$/;"	m	struct:GlueCon
n	constraint.hpp	/^    Vec3 n;$/;"	m	struct:IneqCon
n	constraint.hpp	/^    Vec3 x, n;$/;"	m	struct:EqCon
n	mesh.hpp	/^    Node *n[2]; \/\/ nodes$/;"	m	struct:Edge
n	mesh.hpp	/^    Vec3 n; \/\/ local normal, approximate$/;"	m	struct:Node
n	mesh.hpp	/^    Vec3 n; \/\/ local normal, exact$/;"	m	struct:Face
n	mesh.hpp	/^    Vec3 x0, n;$/;"	m	struct:Plane
n	separateobs.cpp	/^    Vec3 n;$/;"	m	struct:SO::Ixn	file:
n	sparse.hpp	/^    int m, n;$/;"	m	struct:SpMat
nModules	simulation.hpp	/^          PopFilter, Plasticity, Fracture, nModules};$/;"	e	enum:Simulation::__anon2
name	display.cpp	/^struct DisplayMode { string name; double scale; bool active; };$/;"	m	struct:DisplayMode	file:
name	util.cpp	/^template <typename T> string name (const T *p) {$/;"	f
ncon	optimization.hpp	/^    int nvar, ncon;$/;"	m	struct:NLConOpt
nearest_obstacle_planes	nearobs.cpp	/^map<Node*, Plane> nearest_obstacle_planes (const vector<Node*>& nodes, $/;"	f
nearest_point	nearobs.cpp	/^Vec3 nearest_point (const Vec3 &x, const vector<AccelStruct*> &accs,$/;"	f
newtons_method	collision.cpp	/^double newtons_method (double a, double b, double c, double d, double x0,$/;"	f
next_edge_ccw	mesh.hpp	/^inline Edge *next_edge_ccw(const Edge* edge, Node* center) {$/;"	f
next_edge_cw	mesh.hpp	/^inline Edge *next_edge_cw(const Edge* edge, Node* center) {$/;"	f
next_face_ccw	mesh.hpp	/^inline Face *next_face_ccw(const Edge* edge, Node* center) {$/;"	f
next_face_cw	mesh.hpp	/^inline Face *next_face_cw(const Edge* edge, Node* center) {$/;"	f
nf	strainlimiting.cpp	/^    int nn, nf;$/;"	m	struct:SLOpt	file:
nlcg_value_and_grad	nlcg.cpp	/^static void nlcg_value_and_grad (const real_1d_array &x, double &value,$/;"	f	file:
nn	strainlimiting.cpp	/^    int nn, nf;$/;"	m	struct:SLOpt	file:
node	constraint.hpp	/^    Node *node;$/;"	m	struct:EqCon
node	constraint.hpp	/^struct MeshGradV { Node* node; Vec3 f; MeshGradV(Node* i, const Vec3& f) : node(i), f(f) {} };$/;"	m	struct:MeshGradV
node	display.hpp	/^	Node* node;$/;"	m	struct:Annotation
node	handle.hpp	/^    Node *node;$/;"	m	struct:NodeHandle
node	mesh.hpp	/^    Node *node; \/\/ world space$/;"	m	struct:Vert
node	sepstrength.hpp	/^	Node* node;$/;"	m	struct:SplitNode
node_box	bvh.cpp	/^BOX node_box (const Node *node, bool ccd) {$/;"	f
node_edge_prox	proximity.cpp	/^static vector< Min<Edge*> > node_edge_prox;$/;"	v	file:
node_positions	simulation.cpp	/^vector<Vec3> node_positions (const vector<Mesh*> &meshes) {$/;"	f
node_prox	proximity.cpp	/^static vector< Min<Face*> > node_prox[2];$/;"	v	file:
nodes	collision.cpp	/^    Node *nodes[4];$/;"	m	struct:Impact	file:
nodes	collision.cpp	/^    vector<Node*> nodes;$/;"	m	struct:ImpactZone	file:
nodes	constraint.hpp	/^    Node *nodes[2];$/;"	m	struct:GlueCon
nodes	constraint.hpp	/^    Node *nodes[4];$/;"	m	struct:IneqCon
nodes	handle.hpp	/^    Node* nodes[2];$/;"	m	struct:GlueHandle
nodes	localopt.cpp	/^	vector<Node*>& nodes;$/;"	m	struct:LocalOpt	file:
nodes	mesh.hpp	/^    std::vector<Node*> nodes;$/;"	m	struct:Mesh
nodes	separateobs.cpp	/^    vector<Node*> nodes;$/;"	m	struct:SO::SeparationOpt	file:
nold	separateobs.cpp	/^static map<const Face*, Vec3> nold;$/;"	m	namespace:SO	file:
nonlinear_conjugate_gradient_method	nlcg.cpp	/^void nonlinear_conjugate_gradient_method (const NLOpt &problem, OptOptions opt,$/;"	f
nop	display.cpp	/^void nop () {} \/\/ apparently needed by GLUT 3.0$/;"	f
norm	bvh.cpp	/^inline vec3f norm(vec3f &p1, vec3f &p2, vec3f &p3)$/;"	f
norm	lsnewton.cpp	/^static double norm (const vector<double> &x) {return sqrt(dot(x,x));}$/;"	f	file:
norm	trustregion.cpp	/^static double norm (const vector<double> &x) {$/;"	f	file:
norm	vectors.hpp	/^tpl T norm (const VecnT &u) {return sqrt(norm2(u));}$/;"	f
norm2	transformation.cpp	/^double norm2(const Quaternion &q) {$/;"	f
norm2	vectors.hpp	/^tpl T norm2 (const VecnT &u) {return dot(u,u);}$/;"	f
norm2_F	vectors.hpp	/^tpl T norm2_F (const MatmnT &A) {T a = 0; for (int j = 0; j < n; j++) a += norm2(A.col(j)); return a;}$/;"	f
norm_F	vectors.hpp	/^tpl T norm_F (const MatmnT &A) {return sqrt(norm2_F(A));}$/;"	f
normal	display.cpp	/^void normal (const Vec3 &n) {$/;"	f
normal	geometry.cpp	/^template <Space s> Vec3 normal (const Face *face) {$/;"	f
normal	geometry.cpp	/^template <Space s> Vec3 normal (const Node* node) {$/;"	f
normal	sepstrength.hpp	/^	Vec3 normal[2];$/;"	m	struct:SplitNode
normalize	handle.cpp	/^Transformation normalize (const Transformation &T) {$/;"	f
normalize	transformation.cpp	/^Quaternion normalize (const Quaternion &q) {$/;"	f
normalize	vectors.hpp	/^tpl VecnT normalize (const VecnT &u) {T m = norm(u); return m==0 ? VecnT(0) : u\/m;}$/;"	f
not_all_null	mesh.cpp	/^template <typename T1, typename T2> void not_all_null$/;"	f
not_any_null	mesh.cpp	/^template <typename T1, typename T2> void not_any_null$/;"	f
not_null	mesh.cpp	/^template <typename T1, typename T2> void not_null (const T1 *p1, const T2 *p2) {$/;"	f
nsamples	dde.cpp	/^static const int nsamples = 30;$/;"	v	file:
nthreads	collision.cpp	/^static int nthreads = 0;$/;"	v	file:
nthreads	separate.cpp	/^static int nthreads = 0;$/;"	v	file:
nthreads	separateobs.cpp	/^static int nthreads = 0;$/;"	m	namespace:SO	file:
num_bodies	mot_parser.cpp	/^size_t num_bodies(BodyVector &bodies) {$/;"	f
num_frames	mot_parser.cpp	/^size_t num_frames(BodyVector &bodies) {$/;"	f
nvar	optimization.hpp	/^    int nvar, ncon;$/;"	m	struct:NLConOpt
nvar	optimization.hpp	/^    int nvar;$/;"	m	struct:NLOpt
o	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	m	struct:Velocity	file:
obj_grad	collision.cpp	/^void NormalOpt::obj_grad (const double *x, double *grad) const {$/;"	f	class:NormalOpt
obj_grad	separateobs.cpp	/^void SeparationOpt::obj_grad (const double *x, double *grad) const {$/;"	f	class:SO::SeparationOpt
obj_grad	strainlimiting.cpp	/^void SLOpt::obj_grad (const double *x, double *grad) const {$/;"	f	class:SLOpt
objective	collision.cpp	/^double NormalOpt::objective (const double *x) const {$/;"	f	class:NormalOpt
objective	localopt.cpp	/^double LocalOpt<s>::objective (const double *x) const {$/;"	f	class:LocalOpt
objective	plasticity.cpp	/^double EmbedOpt::objective (const double *x) const {$/;"	f	class:EmbedOpt
objective	popfilter.cpp	/^double PopOpt::objective (const double *x) const {$/;"	f	class:PopOpt
objective	separateobs.cpp	/^double SeparationOpt::objective (const double *x) const {$/;"	f	class:SO::SeparationOpt
objective	strainlimiting.cpp	/^double SLOpt::objective (const double *x) const {$/;"	f	class:SLOpt
obs_friction	simulation.hpp	/^    double friction, obs_friction;$/;"	m	struct:Simulation
obs_mass	collision.cpp	/^static double obs_mass;$/;"	v	file:
obs_mass	separate.cpp	/^static double obs_mass;$/;"	v	file:
obs_meshes	collisionutil.cpp	/^const vector<Mesh*> *meshes, *obs_meshes;$/;"	v
obstacle_meshes	simulation.hpp	/^    std::vector<Mesh*> cloth_meshes, obstacle_meshes;$/;"	m	struct:Simulation
obstacle_metric	dynamicremesh.cpp	/^Mat3x3 obstacle_metric (const Face *face, const map<Node*,Plane> &planes) {$/;"	f
obstacles	simulation.hpp	/^    std::vector<Obstacle> obstacles;$/;"	m	struct:Simulation
obtain_subframe_id	io.cpp	/^string obtain_subframe_id() {$/;"	f
offline_loop	runphysics.cpp	/^void offline_loop() {$/;"	f
offset	display.hpp	/^    Vec2 offset;$/;"	m	struct:Pane
opengl_fail	opengl.hpp	/^inline void opengl_fail () {$/;"	f
operator !=	vectors.hpp	/^tpl bool operator!= (const VecnT &u, const VecnT &v) {return !(u==v);}$/;"	f
operator ()	dynamicremesh.cpp	/^    inline bool operator()(const std::pair<double,Edge*> &left, const std::pair<double,Edge*> &right) {$/;"	f	struct:Deterministic_sort
operator ()	separate.cpp	/^    bool operator() (const Vec3& lhs, const Vec3& rhs) const {$/;"	f	struct:cmpOneAxis
operator ()	sparse.hpp	/^    T &operator() (int i, int j) {\/\/ inserts entry as side-effect$/;"	f	struct:SpMat
operator ()	sparse.hpp	/^    T operator() (int i, int j) const {$/;"	f	struct:SpMat
operator ()	vectors.hpp	/^    inline T &operator() (int i, int j) {return c[j][i];}$/;"	f	class:Mat
operator ()	vectors.hpp	/^    inline const T &operator() (int i, int j) const {return c[j][i];}$/;"	f	class:Mat
operator ()	vectors.hpp	/^template <> struct static_assertion_failure<true> {void operator() () {}};$/;"	f	struct:static_assertion_failure
operator *	spline.cpp	/^vector<double> operator* (const vector<double> &x, double a) {$/;"	f
operator *	transformation.cpp	/^Quaternion Quaternion::operator*(const Quaternion& other) const {$/;"	f	class:Quaternion
operator *	transformation.cpp	/^Quaternion Quaternion::operator*(double s) const {$/;"	f	class:Quaternion
operator *	transformation.cpp	/^Transformation Transformation::operator*(const Transformation& other) const {$/;"	f	class:Transformation
operator *	transformation.cpp	/^Transformation Transformation::operator*(double s) const {$/;"	f	class:Transformation
operator *	vectors.hpp	/^inline Vec<3,double>  operator*(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _mm256_mul_pd((__m256d&)u, (__m256d&)v); return (Vec<3,double>&)r; }$/;"	f
operator *	vectors.hpp	/^template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const Mat<m,n,T> &A, const Mat<n,o,T> &B) {Mat<m,o,T> C; for (int k = 0; k < o; k++) C.col(k) = A*B.col(k); return C;}$/;"	f
operator *	vectors.hpp	/^template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const Mat<m,n,T> &A, const MatTransposed<o,n,T> &B) $/;"	f
operator *	vectors.hpp	/^template <int m, int n, int o, typename T> Mat<m,o,T> operator* (const MatTransposed<n,m,T> &A, const Mat<n,o,T> &B) $/;"	f
operator *	vectors.hpp	/^template <int m, int n, typename T> Vec<n, T> operator* (const MatTransposed<m,n,T> &A, const Vec<m, T> &u) $/;"	f
operator *	vectors.hpp	/^tpl MatmnT operator* (const MatmnT &A, const T &a) {return a*A;}$/;"	f
operator *	vectors.hpp	/^tpl MatmnT operator* (const T &a, const MatmnT &A) {MatmnT B; for (int j = 0; j < n; j++) B.col(j) = a*A.col(j); return B;}$/;"	f
operator *	vectors.hpp	/^tpl VecmT operator* (const MatmnT &A, const VecnT &u) {VecmT v = VecmT(0); for (int j = 0; j < n; j++) v += A.col(j)*u[j]; return v;}$/;"	f
operator *	vectors.hpp	/^tpl VecnT operator* (const T &a, const VecnT &u) {VecnT v; for (int i = 0; i < n; i++) v[i] = a*u[i]; return v;}$/;"	f
operator *	vectors.hpp	/^tpl VecnT operator* (const VecnT &u, const T &a) {return a*u;}$/;"	f
operator *<	vectors.hpp	/^template<> inline Vec<3,double> operator*<3,double>(const double &a, const Vec<3,double> &v) { __m256d r = _mm256_mul_pd(_mm256_set1_pd(a), (__m256d&)v); return (Vec<3,double>&)r; }$/;"	v
operator *=	vectors.hpp	/^inline Vec<3,double>& operator*=(Vec<3,double> &r, const Vec<3,double> &v)      { (__m256d&)r = _mm256_mul_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	f
operator *=	vectors.hpp	/^tpl MatmnT &operator*= (MatmnT &A, const T &a) {return A = A*a;}$/;"	f
operator *=	vectors.hpp	/^tpl MatmnT *operator*= (const MatmnT &A, const MatnnT &B) {return A = A*B;}$/;"	f
operator *=	vectors.hpp	/^tpl VecnT &operator*= (VecnT &u, const T &a) {return u = u*a;}$/;"	f
operator +	bvh.hpp	/^	FORCEINLINE kDOP18 operator + ( const kDOP18 &v) const$/;"	f	class:kDOP18
operator +	spline.cpp	/^vector<double> operator+ (const vector<double> &x, const vector<double> &y) {$/;"	f
operator +	transformation.cpp	/^Quaternion Quaternion::operator+(const Quaternion& other) const {$/;"	f	class:Quaternion
operator +	transformation.cpp	/^Transformation Transformation::operator+(const Transformation& other) const {$/;"	f	class:Transformation
operator +	vectors.hpp	/^tpl MatmnT operator+ (const MatmnT &A) {return A;}$/;"	f
operator +	vectors.hpp	/^tpl MatmnT operator+ (const MatmnT &A, const MatmnT &B) {MatmnT C; for (int j = 0; j < n; j++) C.col(j) = A.col(j) + B.col(j); return C;}$/;"	f
operator +	vectors.hpp	/^tpl VecnT operator+ (const VecnT &u) {return u;}$/;"	f
operator +	vectors.hpp	/^tpl VecnT operator+ (const VecnT &u, const VecnT &v) {VecnT w; for (int i = 0; i < n; i++) w[i] = u[i] + v[i]; return w;}$/;"	f
operator +<	vectors.hpp	/^template<> inline Vec<3,double> operator+<3,double>(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _mm256_add_pd((__m256d&)u, (__m256d&)v); return (Vec<3,double>&)r; }$/;"	v
operator +=	bvh.hpp	/^	FORCEINLINE kDOP18 &operator += (const kDOP18 &b)$/;"	f	class:kDOP18
operator +=	bvh.hpp	/^	FORCEINLINE kDOP18 &operator += (const vec3f &p)$/;"	f	class:kDOP18
operator +=	vectors.hpp	/^tpl MatmnT &operator+= (MatmnT &A, const MatmnT &B) {return A = A + B;}$/;"	f
operator +=	vectors.hpp	/^tpl VecnT &operator+= (VecnT &u, const VecnT &v) {return u = u + v;}$/;"	f
operator +=<	vectors.hpp	/^template<> inline Vec<3,double>& operator+=<3,double>(Vec<3,double> &r, const Vec<3,double> &v) { (__m256d&)r = _mm256_add_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	v
operator -	spline.cpp	/^vector<double> operator- (const vector<double> &x, const vector<double> &y) {$/;"	f
operator -	transformation.cpp	/^Quaternion Quaternion::operator-() const {$/;"	f	class:Quaternion
operator -	transformation.cpp	/^Quaternion Quaternion::operator-(const Quaternion& other) const {$/;"	f	class:Quaternion
operator -	transformation.cpp	/^Transformation Transformation::operator-(const Transformation& other) const {$/;"	f	class:Transformation
operator -	vectors.hpp	/^tpl MatmnT operator- (const MatmnT &A) {MatmnT B; for (int j = 0; j < n; j++) B.col(j) = -A.col(j); return B;}$/;"	f
operator -	vectors.hpp	/^tpl MatmnT operator- (const MatmnT &A, const MatmnT &B) {return A + (-B);}$/;"	f
operator -	vectors.hpp	/^tpl VecnT operator- (const VecnT &u) {VecnT v; for (int i = 0; i < n; i++) v[i] = -u[i]; return v;}$/;"	f
operator -	vectors.hpp	/^tpl VecnT operator- (const VecnT &u, const VecnT &v) {return u + (-v);}$/;"	f
operator -<	vectors.hpp	/^template<> inline Vec<3,double> operator-<3,double>(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _mm256_sub_pd((__m256d&)u, (__m256d&)v); return (Vec<3,double>&)r; }$/;"	v
operator -=	vectors.hpp	/^tpl MatmnT &operator-= (MatmnT &A, const MatmnT &B) {return A = A - B;}$/;"	f
operator -=	vectors.hpp	/^tpl VecnT &operator-= (VecnT &u, const VecnT &v) {return u = u - v;}$/;"	f
operator -=<	vectors.hpp	/^template<> inline Vec<3,double>& operator-=<3,double>(Vec<3,double> &r, const Vec<3,double> &v) { (__m256d&)r = _mm256_sub_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	v
operator /	spline.cpp	/^vector<double> operator\/ (const vector<double> &x, double a) {return x*(1\/a);}$/;"	f
operator /	transformation.cpp	/^Quaternion Quaternion::operator\/(double s) const {$/;"	f	class:Quaternion
operator /	transformation.cpp	/^Transformation Transformation::operator\/(double s) const {$/;"	f	class:Transformation
operator /	vectors.hpp	/^inline Vec<3,double>  operator\/(const Vec<3,double> &u, const Vec<3,double> &v) { __m256d r = _mm256_div_pd((__m256d&)u, (__m256d&)v); return (Vec<3,double>&)r; }$/;"	f
operator /	vectors.hpp	/^tpl MatmnT operator\/ (const MatmnT &A, const T &a) {return A*(1\/a);}$/;"	f
operator /	vectors.hpp	/^tpl VecnT operator\/ (const VecnT &u, const T &a) {return u*(1\/a);}$/;"	f
operator /<	vectors.hpp	/^template<> inline Vec<3,double> operator\/<3,double>(const Vec<3,double> &u, const double &a) { __m256d r = _mm256_div_pd((__m256d&)u, _mm256_set1_pd(a)); return (Vec<3,double>&)r; }$/;"	v
operator /=	vectors.hpp	/^inline Vec<3,double>& operator\/=(Vec<3,double> &r, const Vec<3,double> &v)      { (__m256d&)r = _mm256_div_pd((__m256d&)r, (__m256d&)v); return r; }$/;"	f
operator /=	vectors.hpp	/^tpl MatmnT &operator\/= (MatmnT &A, const T &a) {return A = A\/a;}$/;"	f
operator /=	vectors.hpp	/^tpl VecnT &operator\/= (VecnT &u, const T &a) {return u = u\/a;}$/;"	f
operator <	collision.cpp	/^bool operator< (const Impact &impact0, const Impact &impact1) {$/;"	f
operator <	sepstrength.hpp	/^    bool operator<(const SplitNode& o) const { return sep < o.sep; }$/;"	f	struct:SplitNode
operator <<	remesh.cpp	/^ostream &operator<< (ostream &out, const RemeshOp &op) {$/;"	f
operator <<	separateobs.cpp	/^ostream &operator<< (ostream &out, const Ixn &ixn) {out << ixn.f0 << "@" << ixn.b0 << " " << ixn.f1 << "@" << ixn.b1 << " " << ixn.n; return out;}$/;"	f	namespace:SO
operator <<	sparse.hpp	/^std::ostream &operator<< (std::ostream &out, const SpMat<T> &A) {$/;"	f
operator <<	sparse.hpp	/^std::ostream &operator<< (std::ostream &out, const SpVec<T> &v) {$/;"	f
operator <<	taucs.cpp	/^ostream &operator<< (ostream &out, taucs_ccs_matrix *A) {$/;"	f
operator <<	tensormax.cpp	/^ostream &operator<< (ostream &out, const Disk &disk) {out << "Circle[{" << disk.c[0] << "," << disk.c[1] << "}," << disk.r << "]"; return out;}$/;"	f
operator <<	transformation.hpp	/^inline std::ostream &operator<< (std::ostream &out, const Quaternion &q) {out << "(" << q.s << ", " << q.v << ")"; return out;}$/;"	f
operator <<	transformation.hpp	/^inline std::ostream &operator<< (std::ostream &out, const Transformation &t) {out << "(translation: " << t.translation << ", rotation: " << t.rotation << ", scale: " << t.scale << ")"; return out;}$/;"	f
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Edge *edge) {$/;"	f
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Face *face) {$/;"	f
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Node *node) {$/;"	f
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Stats &stats) {$/;"	f
operator <<	util.cpp	/^ostream &operator<< (ostream &out, const Vert *vert) {$/;"	f
operator <<	util.hpp	/^std::ostream &operator<< (std::ostream &out, const std::vector<T> &v) {$/;"	f
operator <<	vectors.hpp	/^tpl std::ostream &operator<< (std::ostream &out, const MatmnT &A) {MatnmT At = transpose(A); out << "(" << std::endl; for (int i = 0; i < m; i++) out << "    " << At.col(i) << (i+1==m?"":",") << std::endl; out << ")"; return out;}$/;"	f
operator <<	vectors.hpp	/^tpl std::ostream &operator<< (std::ostream &out, const VecnT &u) {out << "("; for (int i = 0; i < n; i++) out << (i==0?"":", ") << u[i]; out << ")"; return out;}$/;"	f
operator ==	vectors.hpp	/^tpl bool operator== (const VecnT &u, const VecnT &v) {for(int i=0; i<n; ++i) if(u[i] != v[i]) return false; return true;}$/;"	f
operator []	sparse.hpp	/^    T &operator[] (int i) {\/\/ inserts entry as side-effect$/;"	f	struct:SpVec
operator []	sparse.hpp	/^    T operator[] (int i) const {$/;"	f	struct:SpVec
operator []	vectors.hpp	/^    T &operator[] (int i) {return c[i];}$/;"	f	class:Vec
operator []	vectors.hpp	/^    const T &operator[] (int i) const {return c[i];}$/;"	f	class:Vec
operator delete	vectors.hpp	/^inline void  operator delete(void *ptr)   { aligned_free(ptr); }$/;"	f
operator delete[]	vectors.hpp	/^inline void  operator delete[](void *ptr) { aligned_free(ptr); }$/;"	f
operator new	vectors.hpp	/^inline void* operator new(size_t sz)      { return malloc_align(sz); }$/;"	f
operator new[]	vectors.hpp	/^inline void* operator new[](size_t sz)    { return malloc_align(sz); }$/;"	f
optimize_node	remesh.cpp	/^void optimize_node (Node *node) {$/;"	f
optimize_plastic_embedding	plasticity.cpp	/^void optimize_plastic_embedding (Cloth &cloth) {$/;"	f
orient	mot_parser.hpp	/^    Vec4 orient;$/;"	m	struct:BodyFrame
origami_color	display.cpp	/^Vec3 origami_color (const Mat3x3& M) {$/;"	f
other_node	mesh.hpp	/^inline Node *other_node (const Edge* edge, const Node* node0) {$/;"	f
outer	vectors.hpp	/^tpl MatmnT outer (const VecmT &u, const VecnT &v) {MatmnT A; for (int j = 0; j < n; j++) A.col(j) = u*v[j]; return A;}$/;"	f
overlap	bvh.cpp	/^bool overlap (const BOX &box0, const BOX &box1, float thickness) {$/;"	f
overlaps	bvh.hpp	/^	FORCEINLINE bool overlaps(const kDOP18 &b, kDOP18 &ret) const$/;"	f	class:kDOP18
overlaps	bvh.hpp	/^	FORCEINLINE bool overlaps(const kDOP18& b) const$/;"	f	class:kDOP18
panes	display.cpp	/^Pane Pane::panes[3] = { false, false, true };$/;"	m	class:Pane	file:
panes	display.hpp	/^    static Pane panes[3];$/;"	m	struct:Pane
parent	display.hpp	/^    int window, parent;$/;"	m	struct:Pane
parent	mesh.hpp	/^	Cloth* parent;$/;"	m	struct:Mesh
parent	separate.cpp	/^    vector<size_t> parent, rank;$/;"	m	struct:UnionFind	file:
parse	conf.cpp	/^template <int n> void parse (Vec<n> &v, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^template <typename T> void parse (T &x, const Json::Value &json, const T &x0) {$/;"	f
parse	conf.cpp	/^template <typename T> void parse (vector<T> &v, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (BendingData &data, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Box &box, const Json::Value &json, const Box &box0) {$/;"	f
parse	conf.cpp	/^void parse (Cloth &cloth, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Magic &magic, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Material *&material, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Motion &motion, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Motion::Point &mp, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Range range, const Json::Value &json, Vec2 range0) {$/;"	f
parse	conf.cpp	/^void parse (Remeshing &remeshing, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (StretchingSamples &samples, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Transformation& transform, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Velocity &velocity, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (Wind &wind, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (bool &b, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (double &x, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (int &n, const Json::Value &json) {$/;"	f
parse	conf.cpp	/^void parse (string &s, const Json::Value &json) {$/;"	f
parse_circle_handle	conf.cpp	/^void parse_circle_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f
parse_glue_handle	conf.cpp	/^void parse_glue_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f
parse_handle	conf.cpp	/^void parse_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f
parse_handles	conf.cpp	/^void parse_handles (vector<Handle*> &hans, const Json::Value &jsons,$/;"	f
parse_morph	conf.cpp	/^void parse_morph (Morph &morph, const Json::Value &json,$/;"	f
parse_morphs	conf.cpp	/^void parse_morphs (vector<Morph> &morphs, const Json::Value &json,$/;"	f
parse_motions	conf.cpp	/^void parse_motions (vector<Motion> &motions, const Json::Value &json) {$/;"	f
parse_node_handle	conf.cpp	/^void parse_node_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f
parse_obstacle	conf.cpp	/^void parse_obstacle (Obstacle &obstacle, const Json::Value &json,$/;"	f
parse_obstacles	conf.cpp	/^void parse_obstacles (vector<Obstacle> &obstacles, const Json::Value &json,$/;"	f
parse_soft_handle	conf.cpp	/^void parse_soft_handle (vector<Handle*> &hans, const Json::Value &json,$/;"	f
passive_time	simulation.hpp	/^    double passive_time;$/;"	m	struct:Simulation
perform_breaking	breaking.cpp	/^void perform_breaking(Mesh& mesh) {$/;"	f
perp	dynamicremesh.cpp	/^Mat2x2 perp (const Mat2x2 &A) {return Mat2x2(Vec2(A(1,1), -A(1,0)),$/;"	f
perp	vectors.hpp	/^template <typename T> Vec<2,T> perp (const Vec<2,T> &u) {return Vec<2,T>(-u[1],u[0]);}$/;"	f
physics	simulation.cpp	/^                 physics = Simulation::Physics,$/;"	v	file:
physics_step	simulation.cpp	/^void physics_step (Simulation &sim, const vector<Constraint*> &cons) {$/;"	f
plane_fit	geometry.cpp	/^Plane plane_fit(const Mesh& mesh) {$/;"	f
plastic	display.hpp	/^	static Pane& plastic() { return panes[1]; }$/;"	f	struct:Pane
plastic_flow	cloth.hpp	/^    double yield_stretch, plastic_flow, plastic_limit;$/;"	m	struct:Material
plastic_limit	cloth.hpp	/^    double yield_stretch, plastic_flow, plastic_limit;$/;"	m	struct:Material
plastic_update	plasticity.cpp	/^void plastic_update (Cloth &cloth) {$/;"	f
plasticity	simulation.cpp	/^                 plasticity = Simulation::Plasticity,$/;"	v	file:
plasticity_color	display.cpp	/^Vec3 plasticity_color (const Face *face) {$/;"	f
plasticity_from_embedding	remesh.cpp	/^void plasticity_from_embedding (const vector<Face*> &faces) {$/;"	f
plasticity_step	simulation.cpp	/^void plasticity_step (Simulation &sim) {$/;"	f
point_box_distance	nearobs.cpp	/^double point_box_distance (const Vec3 &x, const BOX &box) {$/;"	f
points	spline.hpp	/^    std::vector<Point> points;$/;"	m	class:Spline
popfilter	simulation.cpp	/^                 popfilter = Simulation::PopFilter,$/;"	v	file:
pos	collision.cpp	/^Vec3 pos (const Node *node, double t) {$/;"	f
pos	display.cpp	/^Vec3 Pane::pos(Vert* v) {$/;"	f	class:Pane
pos	display.hpp	/^	Vec3 pos, dir;$/;"	m	struct:Annotation
pos	geometry.hpp	/^template <> inline Vec3 &pos<MS> (Vert *vert) {return vert->u;}$/;"	f
pos	geometry.hpp	/^template <> inline Vec3 &pos<PS> (Node *node) {return node->y;}$/;"	f
pos	geometry.hpp	/^template <> inline Vec3 &pos<PS> (Vert *vert) {return vert->node->y;}$/;"	f
pos	geometry.hpp	/^template <> inline Vec3 &pos<WS> (Node *node) {return node->x;}$/;"	f
pos	geometry.hpp	/^template <> inline Vec3 &pos<WS> (Vert *vert) {return vert->node->x;}$/;"	f
pos	geometry.hpp	/^template <> inline const Vec3 &pos<MS> (const Vert *vert) {return vert->u;}$/;"	f
pos	geometry.hpp	/^template <> inline const Vec3 &pos<PS> (const Node *node) {return node->y;}$/;"	f
pos	geometry.hpp	/^template <> inline const Vec3 &pos<PS> (const Vert *vert) {return vert->node->y;}$/;"	f
pos	geometry.hpp	/^template <> inline const Vec3 &pos<WS> (const Node *node) {return node->x;}$/;"	f
pos	geometry.hpp	/^template <> inline const Vec3 &pos<WS> (const Vert *vert) {return vert->node->x;}$/;"	f
pos	morph.cpp	/^Vec3 Morph::pos (double t, const Vec3 &u) const {$/;"	f	class:Morph
pos	mot_parser.hpp	/^    Vec3 pos;$/;"	m	struct:BodyFrame
pos	separate.cpp	/^Vec3 pos (const Face *face, const Bary &b) {$/;"	f
pos	separateobs.cpp	/^Vec3 pos (const Face *face, const Bary &b) {$/;"	f	namespace:SO
pos	spline.cpp	/^T Spline<T>::pos (double t) const {$/;"	f	class:Spline
precompute	collision.cpp	/^void NormalOpt::precompute (const double *x) const {$/;"	f	class:NormalOpt
precompute	localopt.cpp	/^void LocalOpt<s>::precompute (const double *x) const {$/;"	f	class:LocalOpt
precompute	optimization.hpp	/^    virtual void precompute (const double *x) const {}$/;"	f	struct:NLConOpt
precompute	optimization.hpp	/^    virtual void precompute (const double *x) const {}$/;"	f	struct:NLOpt
precompute	plasticity.cpp	/^void EmbedOpt::precompute (const double *x) const {$/;"	f	class:EmbedOpt
precompute	popfilter.cpp	/^void PopOpt::precompute (const double *x) const {$/;"	f	class:PopOpt
precompute	strainlimiting.cpp	/^void SLOpt::precompute (const double *x) const {$/;"	f	class:SLOpt
prepare	simulation.cpp	/^void prepare (Simulation &sim) {$/;"	f
preserve	mesh.hpp	/^    bool preserve; \/\/ don't remove this node$/;"	m	struct:Node
preserve	mesh.hpp	/^    int preserve;$/;"	m	struct:Edge
preserve_creases	magic.hpp	/^    bool preserve_creases;$/;"	m	struct:Magic
problem	auglag.cpp	/^static const NLConOpt *problem;$/;"	v	file:
problem	lbfgs.cpp	/^static const NLOpt *problem;$/;"	v	file:
problem	nlcg.cpp	/^static const NLOpt *problem;$/;"	v	file:
project	constraint.cpp	/^MeshGrad EqCon::project () {return MeshGrad();}$/;"	f	class:EqCon
project	constraint.cpp	/^MeshGrad GlueCon::project () {return MeshGrad();}$/;"	f	class:GlueCon
project	constraint.cpp	/^MeshGrad IneqCon::project () {$/;"	f	class:IneqCon
project	vectors.hpp	/^template <int m, int n, typename T> Vec<m,T> project (const VecnT &u) {Vec<m,T> v; for (int i = 0; i < m; i++) v[i] = (i<n) ? u[i] : 0; return v;}$/;"	f
project	vectors.hpp	/^template <int m1, int n1, int m2, int n2, typename T> Mat<m1,n1,T> project (const Mat<m2,n2,T> &A) {Mat<m1,n1,T> B; for (int j = 0; j < n1; j++) B.col(j) = (j<n2) ? project<m1>(A.col(j)) : Vec<m1,T>(0); return B;}$/;"	f
project_outside	physics.cpp	/^void project_outside (vector<Node*>& nodes, const vector<Constraint*> &cons) {$/;"	f
project_vertex	remesh.cpp	/^void project_vertex(Vert *vnew, Edge* edge, int s, double d) {$/;"	f
projected_curvature	geometry.cpp	/^template <Space s> Mat2x2 projected_curvature (const Face *face, const Mat2x3& base) {$/;"	f
projection_thickness	magic.hpp	/^    double repulsion_thickness, projection_thickness;$/;"	m	struct:Magic
proximity	simulation.cpp	/^static const int proximity = Simulation::Proximity,$/;"	v	file:
proximity_constraints	proximity.cpp	/^vector<Constraint*> proximity_constraints (vector<Mesh*> &meshes,$/;"	f
proxy	mesh.hpp	/^    CollisionProxy* proxy;$/;"	m	struct:Mesh
quantile	util.cpp	/^double Stats::quantile (double q) const {sort(); return xs[(int)(q*xs.size())];}$/;"	f	class:Stats
r	tensormax.cpp	/^    double r;$/;"	m	struct:Disk	file:
radius	handle.hpp	/^    double radius;$/;"	m	struct:SoftHandle
radius	referenceshape.hpp	/^    double radius;$/;"	m	class:ReferenceSphere
random	displaytesting.cpp	/^template <int n> Vec<n> random () {$/;"	f
rank	separate.cpp	/^    vector<size_t> parent, rank;$/;"	m	struct:UnionFind	file:
raycast	referenceshape.cpp	/^bool ReferenceLinear::raycast(Vec3& p, const Vec3& dir) {$/;"	f	class:ReferenceLinear
raycast	referenceshape.cpp	/^bool ReferenceMesh::raycast(Vec3& p, const Vec3& dir) {$/;"	f	class:ReferenceMesh
raycast	referenceshape.cpp	/^bool ReferenceSphere::raycast(Vec3& p, const Vec3& dir) {$/;"	f	class:ReferenceSphere
read_motion_file	mot_parser.cpp	/^BodyVector read_motion_file(const string& filename) {$/;"	f
read_motion_file	mot_parser.cpp	/^BodyVector read_motion_file(std::istream& istr) {$/;"	f
recompute_Sp_bend	plasticity.cpp	/^void recompute_Sp_bend (Face *face) {$/;"	f
recompute_edge_plasticity	plasticity.cpp	/^void recompute_edge_plasticity (Mesh &mesh) {$/;"	f
recompute_support	subset.cpp	/^void MeshSubset::recompute_support(map<Node*,int>& acc) {$/;"	f	class:MeshSubset
recover_plasticity	displaytesting.cpp	/^static void recover_plasticity (Mesh &mesh) {$/;"	f	file:
red_blue_colorscheme	display.cpp	/^Vec3 red_blue_colorscheme(double v) {$/;"	f
redisplay	display.cpp	/^void redisplay () {$/;"	f
reduce_stretching_stiffnesses	plasticity.cpp	/^void reduce_stretching_stiffnesses (vector<Material*> &materials) {$/;"	f
reduce_xy	vectors.hpp	/^inline Mat<2,2> reduce_xy (const Mat<3,3>& M) { return Mat<2,2> (Vec2(M(0,0),M(0,1)),Vec2(M(1,0),M(1,1))); }$/;"	f
reduce_xy	vectors.hpp	/^inline Vec<2> reduce_xy(const Vec<3>& v) { return Vec<2>(v[0],v[1]); }$/;"	f
ref	mesh.hpp	/^	ReferenceShape *ref;$/;"	m	struct:Mesh
refine_angle	cloth.hpp	/^    double refine_angle, refine_compression, refine_velocity;$/;"	m	struct:Remeshing
refine_compression	cloth.hpp	/^    double refine_angle, refine_compression, refine_velocity;$/;"	m	struct:Remeshing
refine_fracture	cloth.hpp	/^    double refine_fracture;$/;"	m	struct:Remeshing
refine_velocity	cloth.hpp	/^    double refine_angle, refine_compression, refine_velocity;$/;"	m	struct:Remeshing
refit	bvh.cpp	/^DeformBVHNode::refit(bool ccd)$/;"	f	class:DeformBVHNode
refit	bvh.cpp	/^DeformBVHTree::refit()$/;"	f	class:DeformBVHTree
relax_initial_state	simulation.cpp	/^void relax_initial_state (Simulation &sim) {$/;"	f
relax_method	magic.hpp	/^    int relax_method, max_cracks;$/;"	m	struct:Magic
reload	displayreplay.cpp	/^static void reload () {$/;"	f	file:
remeshing	cloth.hpp	/^    Remeshing remeshing;$/;"	m	struct:Cloth
remeshing	simulation.cpp	/^                 remeshing = Simulation::Remeshing,$/;"	v	file:
remeshing_step	displaytesting.cpp	/^static void remeshing_step (Cloth &cloth) {$/;"	f	file:
remeshing_step	simulation.cpp	/^void remeshing_step (Simulation &sim, bool initializing) {$/;"	f
remove	mesh.cpp	/^void Mesh::remove (Edge *edge) {$/;"	f	class:Mesh
remove	mesh.cpp	/^void Mesh::remove (Face* face) {$/;"	f	class:Mesh
remove	mesh.cpp	/^void Mesh::remove (Node* node) {$/;"	f	class:Mesh
remove	mesh.cpp	/^void Mesh::remove (Vert* vert) {$/;"	f	class:Mesh
remove	util.hpp	/^template <typename T> inline void remove (int i, std::vector<T> &xs) {$/;"	f
remove_all	remesh.cpp	/^template <class T> static void remove_all(const vector<T>& a, Mesh& m) { for(size_t i=0; i<a.size(); i++) m.remove(a[i]); }$/;"	f	file:
removed_edges	remesh.hpp	/^    std::vector<Edge*> added_edges, removed_edges;$/;"	m	struct:RemeshOp
removed_faces	remesh.hpp	/^    std::vector<Face*> added_faces, removed_faces;$/;"	m	struct:RemeshOp
removed_nodes	remesh.hpp	/^    std::vector<Node*> added_nodes, removed_nodes;$/;"	m	struct:RemeshOp
removed_verts	remesh.hpp	/^    std::vector<Vert*> added_verts, removed_verts;$/;"	m	struct:RemeshOp
reorient_MS	conf.cpp	/^void reorient_MS(Mesh& mesh) {$/;"	f
replace	util.hpp	/^inline void replace (const T &x0, const T &x1, std::vector<T> &xs) {$/;"	f
replace	util.hpp	/^template <typename T> inline void replace (const T &v0, const T &v1, T vs[3]) {$/;"	f
reproject_all	conf.cpp	/^void reproject_all(Mesh& mesh) {$/;"	f
repulsion_thickness	magic.hpp	/^    double repulsion_thickness, projection_thickness;$/;"	m	struct:Magic
reset_plasticity	plasticity.cpp	/^void reset_plasticity (Cloth &cloth) {$/;"	f
reshape	display.cpp	/^void reshape (int w, int h) {$/;"	f
resize	mot_parser.cpp	/^void resize(BodyVector &bodies, size_t nbodies, size_t nframes) {$/;"	f
restore_stretching_stiffnesses	plasticity.cpp	/^void restore_stretching_stiffnesses (vector<Material*> &materials) {$/;"	f
resume_physics	runphysics.cpp	/^void resume_physics (const vector<string> &args) {$/;"	f
rib_stiffening	magic.hpp	/^    double rib_stiffening;$/;"	m	struct:Magic
right_handed	vectors.hpp	/^template <typename T> bool right_handed (const Vec<3,T> &u, const Vec<3,T> &v, const Vec<3,T> &w) {return stp(u,v,w) >= 0;}$/;"	f
root	collisionutil.hpp	/^    BVHNode *root;$/;"	m	struct:AccelStruct
rotate	transformation.cpp	/^Vec3 Quaternion::rotate (const Vec3 &x) const {$/;"	f	class:Quaternion
rotation	transformation.hpp	/^    Quaternion rotation;$/;"	m	struct:Transformation
row	vectors.hpp	/^    VecnT row (int i) const {VecnT R; for(int col = 0; col < n; ++col) { R[col] = c[col][i]; } return R; }$/;"	f	class:Mat
rowmat	physics.cpp	/^template <int n> Mat<1,n> rowmat (const Vec<n> &v) {$/;"	f
rows	sparse.hpp	/^    std::vector< SpVec<T> > rows;$/;"	m	struct:SpMat
rows	vectors.hpp	/^	static Mat rows (VecnT x, VecnT y) { Mat<2,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x[i]; M.col(i)[1] = y[i]; } return M; }$/;"	f	class:Mat
rows	vectors.hpp	/^    static Mat rows (VecnT x, VecnT y, VecnT z) { Mat<3,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x[i]; M.col(i)[1] = y[i]; M.col(i)[2] = z[i];} return M; }$/;"	f	class:Mat
rows	vectors.hpp	/^    static Mat rows (VecnT x, VecnT y, VecnT z, VecnT w) { Mat<4,n,T> M; for(int i = 0; i < n; i++) { M.col(i)[0] = x[i]; M.col(i)[1] = y[i]; M.col(i)[2] = z[i]; M.col(i)[3] = w[i];} return M; }$/;"	f	class:Mat
run_glut	display.cpp	/^void run_glut() {$/;"	f
run_physics	runphysics.cpp	/^void run_physics (const vector<string> &args) {$/;"	f
running	displayphysics.cpp	/^static bool running = false;$/;"	v	file:
running	displayreplay.cpp	/^static bool running = false;$/;"	v	file:
s	dde.hpp	/^struct StretchingSamples {Vec4 s[40][40][40];};$/;"	m	struct:StretchingSamples
s	strainlimiting.cpp	/^    mutable vector<double> s;$/;"	m	struct:SLOpt	file:
s	transformation.hpp	/^    double s;$/;"	m	struct:Quaternion
s	vectors.hpp	/^    Vec<n> s;$/;"	m	struct:SVD
safe_normal	remesh.cpp	/^Vec3 safe_normal(Face* face) {$/;"	f
save	runphysics.cpp	/^static void save (vector<Mesh*> &meshes, int frame) {$/;"	f	file:
save	runphysics.cpp	/^void save (Simulation &sim, int frame) {$/;"	f
save	util.hpp	/^	bool save() { return mode == Save; }$/;"	f	struct:Serialize
save_every	simulation.hpp	/^    int frame_steps, save_every;$/;"	m	struct:Simulation
save_obj	io.cpp	/^void save_obj (const Mesh &mesh, const string &filename) {$/;"	f
save_objs	io.cpp	/^void save_objs (const vector<Mesh*> &meshes, const string &prefix) {$/;"	f
save_obstacle_transforms	displayreplay.cpp	/^static void save_obstacle_transforms (const vector<Obstacle> &obs, int frame,$/;"	f	file:
save_png	io.cpp	/^void save_png (const char *filename, int width, int height,$/;"	f
save_screenshot	io.cpp	/^void save_screenshot (const string &filename) {$/;"	f
save_state	io.cpp	/^void save_state (T& state, const string &prefix) {$/;"	f
save_timings	runphysics.cpp	/^static void save_timings () {$/;"	f	file:
save_transformation	io.cpp	/^void save_transformation (const Transformation &tr, const string &filename) {$/;"	f
scalar_mult	lsnewton.cpp	/^static void scalar_mult (vector<double> &v, double a, const vector<double> &x) {$/;"	f	file:
scalar_mult	trustregion.cpp	/^static void scalar_mult (vector<double> &v, double a, const vector<double> &x) {$/;"	f	file:
scale	display.cpp	/^struct DisplayMode { string name; double scale; bool active; };$/;"	m	struct:DisplayMode	file:
scale	display.hpp	/^    double scale;$/;"	m	struct:Pane
scale	transformation.hpp	/^    double scale;$/;"	m	struct:Transformation
segfault	util.cpp	/^void segfault() {$/;"	f
select_element	display.cpp	/^void select_element(int x, int y, int button) {$/;"	f
sep	mesh.hpp	/^	double sep;$/;"	m	struct:Node
sep	sepstrength.hpp	/^	double sep;$/;"	m	struct:SplitNode
separate	separate.cpp	/^void separate (vector<Mesh*> &meshes, const vector<Mesh*> &obs_meshes) {$/;"	f
separate_obstacles	separateobs.cpp	/^void separate_obstacles (vector<Mesh*> &obs_meshes,$/;"	f
separate_obstacles	separateobs.cpp	/^void separate_obstacles (vector<Mesh*> &obs_meshes,$/;"	f	namespace:SO
separation	simulation.cpp	/^                 separation = Simulation::Separation,$/;"	v	file:
separation_step_size	magic.hpp	/^    double separation_step_size;$/;"	m	struct:Magic
separation_strength	sepstrength.cpp	/^double separation_strength(Node* node, SplitNode* split, bool always_compute) {$/;"	f
serialize_header	io.cpp	/^void serialize_header(Serialize& s) {$/;"	f
serialize_link	mesh.cpp	/^template<class T> void serialize_link(T*& p, vector<T*>& src, Serialize& s, const string& id) {$/;"	f
serialize_links	mesh.cpp	/^template<class T> void serialize_links(vector<T*>& v, vector<T*>& src, Serialize& s, const string& id) {$/;"	f
serialize_minvec	proximity.cpp	/^template<class T> void serialize_minvec(vector<Min<T*> >& v, Serialize& s, const string& name) {$/;"	f
serialize_vector	mesh.cpp	/^template<class T> void serialize_vector(vector<T*>& v, Serialize &s, const string& id) {$/;"	f
serializer	constraint.cpp	/^template<> void serializer<vector<Constraint*> >(vector<Constraint*>& x, Serialize& s, const string& n) { $/;"	f
serializer	constraint.cpp	/^void IneqCon::serializer(Serialize& s, const std::string& name) {$/;"	f	class:IneqCon
serializer	constraint.hpp	/^    virtual void serializer(Serialize& s, const std::string& name) {};$/;"	f	struct:Constraint
serializer	io.cpp	/^template<> void serializer<Simulation>(Simulation& sim, Serialize& s, const string& n) {$/;"	f
serializer	mesh.cpp	/^void Edge::serializer(Serialize& s) {$/;"	f	class:Edge
serializer	mesh.cpp	/^void Face::serializer(Serialize& s) {$/;"	f	class:Face
serializer	mesh.cpp	/^void Mesh::serializer(Serialize& s) {$/;"	f	class:Mesh
serializer	mesh.cpp	/^void Node::serializer(Serialize& s) {$/;"	f	class:Node
serializer	mesh.cpp	/^void Vert::serializer(Serialize& s) {$/;"	f	class:Vert
serializer	proximity.cpp	/^template<> void serializer<vector<Min<Edge*> > >(vector<Min<Edge*> >& x, Serialize& s, const string& n) { serialize_minvec(x,s,n); }$/;"	f
serializer	proximity.cpp	/^template<> void serializer<vector<Min<Face*> > >(vector<Min<Face*> >& x, Serialize& s, const string& n) { serialize_minvec(x,s,n); }$/;"	f
serializer	proximity.cpp	/^template<> void serializer<vector<Min<Node*> > >(vector<Min<Node*> >& x, Serialize& s, const string& n) { serialize_minvec(x,s,n); }$/;"	f
serializer	util.cpp	/^template<> void serializer<Mat2x2>(Mat2x2& x, Serialize& s,const string& n) { return serializer_mat(x,s,n); }$/;"	f
serializer	util.cpp	/^template<> void serializer<Mat3x3>(Mat3x3& x, Serialize& s,const string& n) { return serializer_mat(x,s,n); }$/;"	f
serializer	util.cpp	/^template<> void serializer<Vec2>(Vec2& x, Serialize& s,const string& n) { return serializer_vec(x,s,n); }$/;"	f
serializer	util.cpp	/^template<> void serializer<Vec3>(Vec3& x, Serialize &s,const string& n) { return serializer_vec(x,s,n); }$/;"	f
serializer	util.cpp	/^template<> void serializer<vector<Vec3> >(vector<Vec3>& x, Serialize& s, const string& n) { return serializer_dvec(x,s,n); }$/;"	f
serializer	util.cpp	/^template<> void serializer<vector<double> >(vector<double>& x, Serialize& s, const string& n) { return serializer_dvec(x,s,n); }$/;"	f
serializer	util.cpp	/^void serializer(T& v, Serialize& s, const string& name) { $/;"	f
serializer_array	util.hpp	/^void serializer_array(std::vector<T>& v, Serialize& s, const std::string& name) { $/;"	f
serializer_dvec	util.cpp	/^void serializer_dvec(vector<T>& v, Serialize& s, const string& name) { $/;"	f
serializer_mat	util.cpp	/^void serializer_mat(Mat<n,n>& x, Serialize& s, const string& name) { $/;"	f
serializer_vec	util.cpp	/^void serializer_vec(Vec<n>& x, Serialize& s, const string& name) { $/;"	f
serializer_vec	vectors.hpp	/^tpl void serializer_vec(gzFile fp, VecnT& v, bool save) { for(int i=0; i<3; i++) serializer(fp, v[i], save); }$/;"	f
set_flag	subset.cpp	/^void MeshSubset::set_flag(int flag) {$/;"	f	class:MeshSubset
set_indices	mesh.cpp	/^void set_indices (Mesh &mesh) {$/;"	f
set_indices	mesh.cpp	/^void set_indices (vector<Mesh*>& meshes) {$/;"	f
set_null	remesh.cpp	/^void RemeshOp::set_null(std::vector<Edge*>& v) {$/;"	f	class:RemeshOp
set_row	vectors.hpp	/^    void set_row(int i, const VecnT& v) { for(int col = 0; col < n; ++col) c[col][i] = v[col]; }$/;"	f	class:Mat
set_submat	optimization.hpp	/^inline void set_submat (SpMat<double> &A, int i, int j, const Mat3x3 &Aij) {$/;"	f
set_subvec	optimization.hpp	/^inline void set_subvec (double *x, int i, const Vec3 &xi) {$/;"	f
set_subvec	optimization.hpp	/^template <int n> void set_subvec (double *x, int i, const Vec<n> &xi) {$/;"	f
set_unsigned_ee_distance	geometry.cpp	/^bool set_unsigned_ee_distance (const Vec3 &x0, const Vec3 &x1,$/;"	f
set_unsigned_ve_distance	geometry.cpp	/^bool set_unsigned_ve_distance (const Vec3 &x, const Vec3 &y0, const Vec3 &y1,$/;"	f
set_unsigned_vf_distance	geometry.cpp	/^bool set_unsigned_vf_distance (const Vec3 &x,$/;"	f
sg	strainlimiting.cpp	/^    mutable vector<Mat3x3> sg;$/;"	m	struct:SLOpt	file:
sgn	util.hpp	/^template <typename T> T sgn (const T &x) {return x<0 ? -1 : 1;}$/;"	f
should_flip	dynamicremesh.cpp	/^bool should_flip (const Edge *edge) {$/;"	f
should_flip2	dynamicremesh.cpp	/^inline bool should_flip2 (const Vec2& x, const Vec2& y, const Vec2& z, const Vec2& w, $/;"	f
shrink_face	display.cpp	/^void shrink_face (const Face *face, double shrink_factor, double shrink_max,$/;"	f
sigma	mesh.hpp	/^    Mat3x3 sigma;$/;"	m	struct:Face
signed_ee_distance	geometry.cpp	/^double signed_ee_distance (const Vec3 &x0, const Vec3 &x1,$/;"	f
signed_ve_distance	geometry.cpp	/^double signed_ve_distance (const Vec3 &x,const Vec3 &y0, const Vec3 &y1,$/;"	f
signed_vf_distance	geometry.cpp	/^double signed_vf_distance (const Vec3 &x,$/;"	f
sim	runphysics.cpp	/^Simulation sim;$/;"	v
sim_step	runphysics.cpp	/^void sim_step() {$/;"	f
single_step	simulation.cpp	/^bool single_step = false;$/;"	v
singular_value_decomposition	vectors.cpp	/^template <int m, int n> SVD<m,n> singular_value_decomposition (const Mat<m,n> &A) {$/;"	f
singular_value_decomposition	vectors.cpp	/^template<> SVD<3,2> singular_value_decomposition<3,2> (const Mat<3,2> &A) {$/;"	f
size_max	cloth.hpp	/^    double size_min, size_max, size_uniform; \/\/ size limits$/;"	m	struct:Remeshing
size_min	cloth.hpp	/^    double size_min, size_max, size_uniform; \/\/ size limits$/;"	m	struct:Remeshing
size_uniform	cloth.hpp	/^    double size_min, size_max, size_uniform; \/\/ size limits$/;"	m	struct:Remeshing
sizing	mesh.hpp	/^    Mat3x3 sizing;$/;"	m	struct:Vert
snprintf	winport.hpp	47;"	d
solve_cubic	collision.cpp	/^int solve_cubic (double a, double b, double c, double d, double x[3]) {$/;"	f
solve_ixns	separateobs.cpp	/^void solve_ixns (const vector<Ixn> &ixns) {$/;"	f	namespace:SO
solve_llsq	vectors.cpp	/^template <int m, int n> Vec<n> solve_llsq(const Mat<m,n> &A, const Vec<m>& b) {$/;"	f
solve_quadratic	util.cpp	/^int solve_quadratic (double a, double b, double c, double x[2]) {$/;"	f
solve_symmetric	vectors.cpp	/^template<> Vec2 solve_symmetric(const Mat2x2& A, const Vec2& b) {$/;"	f
solve_symmetric	vectors.cpp	/^template<> Vec3 solve_symmetric(const Mat3x3& A, const Vec3& b) {$/;"	f
sort	util.cpp	/^void Stats::sort () const {$/;"	f	class:Stats
sorted	util.hpp	/^    mutable bool sorted;$/;"	m	struct:Stats
sparse_to_taucs	taucs.cpp	/^taucs_ccs_matrix *sparse_to_taucs (const SpMat<double> &As) {$/;"	f
sparse_to_taucs	taucs.cpp	/^template <int m> taucs_ccs_matrix *sparse_to_taucs (const SpMat< Mat<m,m> > &As) {$/;"	f
special	display.hpp	/^    void (*special) (int, int, int);$/;"	m	struct:GlutCallbacks
special	displayreplay.cpp	/^static void special (int key, int x, int y) {$/;"	f	file:
split_edge	remesh.cpp	/^RemeshOp split_edge (Edge* edge, double d) {$/;"	f
split_edge_with_plane	breaking.cpp	/^Edge* split_edge_with_plane(Face* face, Node* node, Vec3& n) {$/;"	f
split_meshes	misc.cpp	/^void split_meshes (const vector<string> &args) {$/;"	f
split_sector	breaking.cpp	/^void split_sector(Node* node, Edge* start, Edge* end, MeshSubset& subset) {$/;"	f
split_worst_edge	dynamicremesh.cpp	/^bool split_worst_edge (MeshSubset* subset, const vector<Edge*>& edges) {$/;"	f
sq	vectors.hpp	/^inline double sq (double x) {return x*x;}$/;"	f
sqr	util.hpp	/^template <typename T> T sqr (const T& x) { return x*x; }$/;"	f
sqrt	dynamicremesh.cpp	/^template <int n> Mat<n,n> sqrt (const Mat<n,n> &A) {$/;"	f
sqrt	winport.hpp	/^inline double sqrt(int n) { return sqrt(double(n)); }$/;"	f
start_time	handle.hpp	/^    double start_time, end_time, fade_time;$/;"	m	struct:Handle
start_time	obstacle.hpp	/^    double start_time, end_time;$/;"	m	struct:Obstacle
static_assert	vectors.hpp	313;"	d
static_assert	vectors.hpp	73;"	d
static_assertion_failure	vectors.hpp	/^template <> struct static_assertion_failure<true> {void operator() () {}};$/;"	s
static_remesh	dynamicremesh.cpp	/^void static_remesh (Mesh& mesh) {$/;"	f
step	simulation.hpp	/^    int frame, step;$/;"	m	struct:Simulation
stepDebug	display.cpp	/^bool stepDebug;$/;"	v
step_mesh	simulation.cpp	/^void step_mesh (Mesh &mesh, double dt) {$/;"	f
step_time	simulation.hpp	/^    double frame_time, step_time;$/;"	m	struct:Simulation
stiff	constraint.hpp	/^    double stiff;$/;"	m	struct:EqCon
stiff	constraint.hpp	/^    double stiff;$/;"	m	struct:GlueCon
stiff	constraint.hpp	/^    double stiff;$/;"	m	struct:IneqCon
stp	vectors.hpp	/^template <typename T> T stp (const Vec<3,T> &u, const Vec<3,T> &v, const Vec<3,T> &w) {return dot(u,cross(v,w));}$/;"	f
strain_color	display.cpp	/^Vec3 strain_color (const Face *face) {$/;"	f
strain_con	strainlimiting.cpp	/^double strain_con (const SLOpt &sl, const double *x, int j, int &sign) {$/;"	f
strain_con_grad	strainlimiting.cpp	/^void strain_con_grad (const SLOpt &sl, const double *x, int j, double factor,$/;"	f
strain_limiting	strainlimiting.cpp	/^void strain_limiting (vector<Mesh*> &meshes, const vector<StrainLimit> &strain_limits,$/;"	f
strain_limits	strainlimiting.cpp	/^    const vector<StrainLimit> &strain_limits;$/;"	m	struct:SLOpt	file:
strain_max	cloth.hpp	/^    double strain_min, strain_max; \/\/ strain limits$/;"	m	struct:Material
strain_min	cloth.hpp	/^    double strain_min, strain_max; \/\/ strain limits$/;"	m	struct:Material
strainlimiting	simulation.cpp	/^                 strainlimiting = Simulation::StrainLimiting,$/;"	v	file:
strainlimiting_step	simulation.cpp	/^void strainlimiting_step (Simulation &sim, const vector<Constraint*> &cons) {$/;"	f
strainzeroing_step	simulation.cpp	/^void strainzeroing_step (Simulation &sim) {$/;"	f
strength	handle.hpp	/^    double strength (double t) {$/;"	f	struct:Handle
stretch_plasticity_from_embedding	plasticity.cpp	/^Mat3x3 stretch_plasticity_from_embedding(const Face *face) {$/;"	f
stretching_energy	physics.cpp	/^double stretching_energy (const Face *face) {$/;"	f
stretching_force	physics.cpp	/^pair<Mat9x9,Vec9> stretching_force (const Face *face) {$/;"	f
stretching_stiffness	dde.cpp	/^Vec4 stretching_stiffness (const Mat2x2 &G, const StretchingSamples &samples) {$/;"	f
stringf	util.cpp	/^inline string stringf (const string &format, ...) {$/;"	f
submat3	physics.cpp	/^template <int m, int n> Mat<3,3> submat3 (const Mat<m,n> &A, int i, int j) {$/;"	f
subset	util.hpp	/^inline bool subset (const std::vector<T> &xs, const std::vector<T> &ys) {$/;"	f
subvec3	physics.cpp	/^template <int n> Vec<3> subvec3 (const Vec<n> &b, int i) {$/;"	f
sum	util.hpp	/^    double sum;$/;"	m	struct:Stats
support_nodes	subset.hpp	/^	std::vector<Node*> support_nodes;$/;"	m	class:MeshSubset
symmetrize	blockvectors.hpp	/^template <> inline Mat<3,4> symmetrize<2> () {$/;"	f
t	collision.cpp	/^    double t;$/;"	m	struct:Impact	file:
t	separate.cpp	/^    double t[2];$/;"	m	struct:EdgeClipping	file:
t	spline.hpp	/^    struct Point {double t; T x, v;};$/;"	m	struct:Spline::Point
t	vectors.hpp	/^    MatnmT t () const {return transpose(*this);}$/;"	f	class:Mat
t	vectors.hpp	/^    const Mat<m,n,T>& t () const {return static_cast<const Mat<m, n, T>&>(*this);}$/;"	f	class:MatTransposed
t0	sepstrength.cpp	/^	Vec3 t0, t1;$/;"	m	struct:FanPrecomp	file:
t1	sepstrength.cpp	/^	Vec3 t0, t1;$/;"	m	struct:FanPrecomp	file:
tail	tensormax.cpp	/^template <typename T> vector<T> tail (const vector<T> &v) {$/;"	f
targets	morph.hpp	/^    std::vector<Mesh> targets;$/;"	m	struct:Morph
taucs_linear_solve	taucs.cpp	/^template <int m> vector< Vec<m> > taucs_linear_solve$/;"	f
taucs_linear_solve	taucs.cpp	/^vector<double> taucs_linear_solve (const SpMat<double> &A, const vector<double> &b) {$/;"	f
tensor_max	tensormax.cpp	/^Mat2x2 tensor_max (const vector<Mat2x2> &Ms) {$/;"	f
test_state	io.hpp	/^void test_state (T& state, const std::string& prefix) {$/;"	f
then	timer.hpp	/^    boost::posix_time::ptime then;$/;"	m	struct:Timer
theta_ideal	mesh.hpp	/^    double theta_ideal, damage; \/\/ rest dihedral angle, damage parameter$/;"	m	struct:Edge
theta_ideal	remesh.cpp	/^    vector<double> theta_ideal;$/;"	m	struct:PlasticityStash	file:
thickness	cloth.hpp	/^    double thickness;$/;"	m	struct:Material
thickness	collision.cpp	/^static const double &thickness = ::magic.projection_thickness;$/;"	v	file:
thickness	separate.cpp	/^static const double &thickness = ::magic.projection_thickness;$/;"	v	file:
tick	timer.cpp	/^void Timer::tick () {$/;"	f	class:Timer
time	simulation.hpp	/^    double time;$/;"	m	struct:Simulation
timers	simulation.hpp	/^    Timer timers[nModules];$/;"	m	struct:Simulation
timingfile	runphysics.cpp	/^static fstream timingfile;$/;"	v	file:
to_axisangle	transformation.cpp	/^pair<Vec3, double> Quaternion::to_axisangle() const {$/;"	f	class:Quaternion
tock	timer.cpp	/^void Timer::tock () {$/;"	f	class:Timer
total	timer.hpp	/^    double last, total;$/;"	m	struct:Timer
toughness	cloth.hpp	/^    double toughness, fracture_bend_thickness; \/\/ fracture toughness$/;"	m	struct:Material
tpl	vectors.hpp	142;"	d
tpl	vectors.hpp	148;"	d
tpl	vectors.hpp	219;"	d
tpl	vectors.hpp	75;"	d
trace	vectors.hpp	/^template <int n, typename T> T trace (const MatnnT &A) {T t = 0; for (int j = 0; j < n; j++) t += A(j,j); return t;}$/;"	f
transform_spline	obstacle.hpp	/^    const Motion *transform_spline;$/;"	m	struct:Obstacle
translation	transformation.hpp	/^    Vec3 translation;$/;"	m	struct:Transformation
transpose	blockvectors.hpp	/^template <int m, int n> Mat<m*n,m*n,double> transpose () {$/;"	f
transpose	vectors.hpp	/^tpl MatnmT transpose (const MatmnT &A) {MatnmT B; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) B(j,i) = A(i,j); return B;}$/;"	f
tree	collisionutil.hpp	/^    BVHTree tree;$/;"	m	struct:AccelStruct
tri2obj	misc.cpp	/^void tri2obj (const vector<string> &args) {$/;"	f
triangle_ray_test	geometry.cpp	/^bool triangle_ray_test (const Vec3 &x0, const Vec3& x1, const Vec3& x2,$/;"	f
triangle_to_obj	io.cpp	/^void triangle_to_obj (const string &inname, const string &outname) {$/;"	f
triangulate	io.cpp	/^vector<Face*> triangulate (const vector<Vert*> &verts) {$/;"	f
trust_region_method	trustregion.cpp	/^void trust_region_method (const NLOpt &problem, OptOptions opt, bool verbose) {$/;"	f
try_edge_collapse	dynamicremesh.cpp	/^RemeshOp try_edge_collapse (Edge *edge, int which) {$/;"	f
try_move_node	remesh.cpp	/^bool try_move_node (Node* node, Edge* edge, double d) {$/;"	f
type	collision.cpp	/^    enum Type {VF, EE} type;$/;"	m	struct:Impact	typeref:enum:Impact::Type	file:
u	handle.hpp	/^    Vec2 u;$/;"	m	struct:CircleHandle
u	mesh.hpp	/^    Vec3 u; \/\/ material space$/;"	m	struct:Vert
uint	util.hpp	/^typedef unsigned int uint;$/;"	t
umax	conf.cpp	/^    Vec2 umin, umax;$/;"	m	struct:Box	file:
umin	conf.cpp	/^    Vec2 umin, umax;$/;"	m	struct:Box	file:
unify	separate.cpp	/^    void unify (size_t x, size_t y) {$/;"	f	struct:UnionFind
unsigned_ee_distance	geometry.cpp	/^double unsigned_ee_distance (const Vec3 &x0, const Vec3 &x1,$/;"	f
unsigned_vf_distance	geometry.cpp	/^double unsigned_vf_distance (const Vec3 &x,$/;"	f
update	localopt.cpp	/^void LocalOpt<s>::update(const double* x) const {$/;"	f	class:LocalOpt
update	proxy.cpp	/^void FloorProxy::update(Mesh& mesh) {$/;"	f	class:FloorProxy
update	remesh.cpp	/^void RemeshOp::update(std::vector<Edge*>& v) {$/;"	f	class:RemeshOp
update	remesh.cpp	/^void RemeshOp::update(std::vector<Face*>& v) {$/;"	f	class:RemeshOp
update	remesh.cpp	/^void RemeshOp::update(std::vector<Node*>& v) {$/;"	f	class:RemeshOp
update_accel_struct	collisionutil.cpp	/^void update_accel_struct (AccelStruct &acc) {$/;"	f
update_active	collision.cpp	/^void update_active (const vector<AccelStruct*> &accs,$/;"	f
update_active	separate.cpp	/^void update_active (const vector<AccelStruct*> &accs,$/;"	f
update_active	separateobs.cpp	/^void update_active (const vector<AccelStruct*> &accs, const vector<Ixn> &ixns) {$/;"	f	namespace:SO
update_nearest_point	nearobs.cpp	/^void update_nearest_point (const Vec3 &x, BVHNode *node, NearPoint &p) {$/;"	f
update_nearest_point	nearobs.cpp	/^void update_nearest_point (const Vec3 &x, const Face *face, NearPoint &p) {$/;"	f
update_obstacles	simulation.cpp	/^void update_obstacles (Simulation &sim, bool update_positions) {$/;"	f
update_support	subset.cpp	/^void MeshSubset::update_support() {$/;"	f	class:MeshSubset
update_velocities	simulation.cpp	/^void update_velocities (vector<Mesh*> &meshes, vector<Vec3> &xold, double dt) {$/;"	f
update_x0	mesh.cpp	/^void update_x0 (Mesh &mesh) {$/;"	f
use_dde	cloth.hpp	/^    bool use_dde; \/\/ use DDE material files$/;"	m	struct:Material
uuid	mesh.hpp	/^    int uuid;$/;"	m	struct:Node
uuid_src	mesh.cpp	/^int uuid_src = 0;$/;"	v
v	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	m	struct:Velocity	file:
v	mesh.hpp	/^    Vec3 x, x0, v; \/\/ position, old (collision-free) position, velocity$/;"	m	struct:Node
v	mesh.hpp	/^    Vert* v[3]; \/\/ verts$/;"	m	struct:Face
v	spline.hpp	/^    struct Point {double t; T x, v;};$/;"	m	struct:Spline::Point
v	transformation.hpp	/^    Vec3 v;$/;"	m	struct:Quaternion
val	nearobs.cpp	/^    T val;$/;"	m	struct:Min	file:
val	proximity.cpp	/^    T val;$/;"	m	struct:Min	file:
validate_handles	simulation.cpp	/^void validate_handles (const Simulation &sim) {$/;"	f
value	constraint.cpp	/^double EqCon::value (int *sign) {$/;"	f	class:EqCon
value	constraint.cpp	/^double GlueCon::value (int *sign) {$/;"	f	class:GlueCon
value	constraint.cpp	/^double IneqCon::value (int *sign) {$/;"	f	class:IneqCon
vec3f	bvh.hpp	/^typedef Vec3 vec3f;$/;"	t
vec_max	util.hpp	/^Vec<n,T> vec_max (const Vec<n,T> &u, const Vec<n,T> &v) {$/;"	f
vec_min	util.hpp	/^Vec<n,T> vec_min (const Vec<n,T> &u, const Vec<n,T> &v) {$/;"	f
vec_to_mat	blockvectors.hpp	/^Mat<m,n,T> vec_to_mat (const Vec<m*n,T> &a) {$/;"	f
vel	spline.cpp	/^T Spline<T>::vel (double t) const {$/;"	f	class:Spline
velocity	simulation.hpp	/^    Vec3 velocity;$/;"	m	struct:Wind
verbose	dynamicremesh.cpp	/^static const bool verbose = false;$/;"	v	file:
verbose	lsnewton.cpp	/^static bool verbose;$/;"	v	file:
verbose	physics.cpp	/^static const bool verbose = false;$/;"	v	file:
verbose	simulation.cpp	/^static const bool verbose = false;$/;"	v	file:
version	util.hpp	/^	int version;$/;"	m	struct:Serialize
vert_box	bvh.cpp	/^BOX vert_box (const Vert *vert, bool ccd) {$/;"	f
vertex	display.cpp	/^void vertex (const Vec2 &x) {$/;"	f
vertex	display.cpp	/^void vertex (const Vec3 &x) {$/;"	f
verts	mesh.hpp	/^    std::vector<Vert*> verts;$/;"	m	struct:Mesh
verts	mesh.hpp	/^    std::vector<Vert*> verts;$/;"	m	struct:Node
vf_clear_distance	separateobs.cpp	/^double vf_clear_distance (const Face *face0, const Face *face1, const Vec3 &d,$/;"	f	namespace:SO
vf_collision_test	collision.cpp	/^bool vf_collision_test (const Vert *vert, const Face *face, Impact &impact) {$/;"	f
violation	constraint.cpp	/^double violation (double value) {return std::max(-value, 0.);}$/;"	f
volume	bvh.hpp	/^	FORCEINLINE float volume() const { return width()*height()*depth(); }$/;"	f	class:kDOP18
w	collision.cpp	/^    double w[4];$/;"	m	struct:Impact	file:
w	conf.cpp	/^struct Velocity {Vec3 v, w; Vec3 o;};$/;"	m	struct:Velocity	file:
w	constraint.hpp	/^    double w[4];$/;"	m	struct:IneqCon
wait_key	display.cpp	/^void wait_key () {   $/;"	f
weakening	cloth.hpp	/^    double yield_curv, weakening; \/\/ plasticity parameters$/;"	m	struct:Material
wedge	vectors.hpp	/^template <typename T> T wedge (const Vec<2,T> &u, const Vec<2,T> &v) {return u[0]*v[1] - u[1]*v[0];}$/;"	f
weights	morph.hpp	/^    Spline<Weights> weights;$/;"	m	struct:Morph
welzls_algorithm	tensormax.cpp	/^Disk welzls_algorithm (const vector<Disk> &disks) {$/;"	f
width	bvh.hpp	/^	FORCEINLINE float width()  const { return _dist[9] - _dist[0]; }$/;"	f	class:kDOP18
wind	simulation.hpp	/^    Wind wind;$/;"	m	struct:Simulation
wind_force	physics.cpp	/^Vec3 wind_force (const Face *face, const Wind &wind) {$/;"	f
window	display.hpp	/^    int window, parent;$/;"	m	struct:Pane
world	display.hpp	/^	static Pane& world() { return panes[2]; }$/;"	f	struct:Pane
write_motion_file	mot_parser.cpp	/^void write_motion_file(BodyVector &bodies, const string& filename) {$/;"	f
write_motion_file	mot_parser.cpp	/^void write_motion_file(BodyVector &bodies, ostream& ostr) {$/;"	f
x	constraint.hpp	/^    Vec3 x, n;$/;"	m	struct:EqCon
x	display.cpp	/^    int x, y;$/;"	m	struct:MouseState	file:
x	mesh.hpp	/^    Vec3 x, x0, v; \/\/ position, old (collision-free) position, velocity$/;"	m	struct:Node
x	nearobs.cpp	/^    Vec3 x;$/;"	m	struct:NearPoint	file:
x	spline.hpp	/^    struct Point {double t; T x, v;};$/;"	m	struct:Spline::Point
x0	handle.hpp	/^    Vec3 x0;$/;"	m	struct:NodeHandle
x0	localopt.cpp	/^    vector<Vec3> x0;$/;"	m	struct:LocalOpt	file:
x0	mesh.hpp	/^    Vec3 x, x0, v; \/\/ position, old (collision-free) position, velocity$/;"	m	struct:Node
x0	mesh.hpp	/^    Vec3 x0, n;$/;"	m	struct:Plane
x0	popfilter.cpp	/^    vector<Vec3> x0, a0;$/;"	m	struct:PopOpt	file:
xc	handle.hpp	/^    Vec3 xc, dx0, dx1;$/;"	m	struct:CircleHandle
xold	collision.cpp	/^static map<const Node*, Vec3> xold;$/;"	v	file:
xold	separateobs.cpp	/^static map<const Node*, Vec3> xold;$/;"	m	namespace:SO	file:
xold	strainlimiting.cpp	/^    vector<Vec3> xold;$/;"	m	struct:SLOpt	file:
xs	util.hpp	/^    mutable std::vector<double> xs;$/;"	m	struct:Stats
y	display.cpp	/^    int x, y;$/;"	m	struct:MouseState	file:
y	mesh.hpp	/^    Vec3 y; \/\/ plastic embedding$/;"	m	struct:Node
y0	plasticity.cpp	/^    vector<Vec3> y0;$/;"	m	struct:EmbedOpt	file:
yield_curv	cloth.hpp	/^    double yield_curv, weakening; \/\/ plasticity parameters$/;"	m	struct:Material
yield_stretch	cloth.hpp	/^    double yield_stretch, plastic_flow, plastic_limit;$/;"	m	struct:Material
zone	collision.cpp	/^    ImpactZone *zone;$/;"	m	struct:NormalOpt	file:
zoom	display.cpp	/^void zoom (bool in) {$/;"	f
~CollisionProxy	proxy.hpp	/^    virtual ~CollisionProxy() {};$/;"	f	class:CollisionProxy
~Constraint	constraint.hpp	/^    virtual ~Constraint () {};$/;"	f	struct:Constraint
~DeformBVHNode	bvh.cpp	/^DeformBVHNode::~DeformBVHNode()$/;"	f	class:DeformBVHNode
~DeformBVHTree	bvh.cpp	/^DeformBVHTree::~DeformBVHTree()$/;"	f	class:DeformBVHTree
~Handle	handle.hpp	/^    virtual ~Handle () {};$/;"	f	struct:Handle
